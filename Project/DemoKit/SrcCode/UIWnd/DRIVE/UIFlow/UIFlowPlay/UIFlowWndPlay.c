//This source code is generated by UI Designer Studio.

#include "UIFramework.h"
#include "UIFrameworkExt.h"
#include "NVTToolCommand.h"
#include "UIFlowWndPlayRes.c"
#include "UIFlow.h"
#include "Audio.h"

// Photo mode key mask
#define PLAY_KEY_PRESS_MASK        (FLGKEY_KEY_MASK_DEFAULT)
#define PLAY_KEY_RELEASE_MASK      FLGKEY_KEY_MASK_NULL//(FLGKEY_UP | FLGKEY_DOWN | FLGKEY_LEFT | FLGKEY_RIGHT)
#define PLAY_KEY_CONTINUE_MASK     FLGKEY_KEY_CONT_MASK_DEFAULT

static UINT32 g_uiMaskKeyPress      = PLAY_KEY_PRESS_MASK;
static UINT32 g_uiMaskKeyRelease    = PLAY_KEY_RELEASE_MASK;
static UINT32 g_uiMaskKeyContinue   = PLAY_KEY_CONTINUE_MASK;

BOOL g_bUIFlowWndPlayNoImgWndOpened = FALSE;
UINT32  g_uiUIFlowWndPlayCurrentVolume = AUDIO_VOL_7;//AUDIO_VOL_MUTE;

//---------------------UIFlowWndPlayCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndPlay)
CTRL_LIST_ITEM(UIFlowWndPlay_StaticICN_DSCMode)
CTRL_LIST_ITEM(UIFlowWndPlay_StatusICN_Flash)
CTRL_LIST_ITEM(UIFlowWndPlay_StatusICN_EV)
CTRL_LIST_ITEM(UIFlowWndPlay_StaticTXT_Size)
CTRL_LIST_ITEM(UIFlowWndPlay_StatusICN_WB)
CTRL_LIST_ITEM(UIFlowWndPlay_StatusICN_Quality)
CTRL_LIST_ITEM(UIFlowWndPlay_StatusICN_Sharpness)
CTRL_LIST_ITEM(UIFlowWndPlay_StatusICN_Storage)
CTRL_LIST_ITEM(UIFlowWndPlay_StatusICN_Battery)
CTRL_LIST_ITEM(UIFlowWndPlay_TabHistogram)
CTRL_LIST_ITEM(UIFlowWndPlay_StaticTXT_Filename)
CTRL_LIST_ITEM(UIFlowWndPlay_StaticICN_Protect)
CTRL_LIST_ITEM(UIFlowWndPlay_StaticTXT_Date)
CTRL_LIST_ITEM(UIFlowWndPlay_StaticTXT_Time)
CTRL_LIST_ITEM(UIFlowWndPlay_Histo)
CTRL_LIST_ITEM(UIFlowWndPlay_StatusICN_MovPlay)
CTRL_LIST_ITEM(UIFlowWndPlay_StatusICN_MovStop)
CTRL_LIST_ITEM(UIFlowWndPlay_StatusICN_MovBwd)
CTRL_LIST_ITEM(UIFlowWndPlay_StaticTXT_MovPlayTime)
CTRL_LIST_ITEM(UIFlowWndPlay_StatusICN_MovFwd)
CTRL_LIST_ITEM(UIFlowWndPlay_StatusICN_Volumn)
CTRL_LIST_ITEM(UIFlowWndPlay_StaticICN_Print)
CTRL_LIST_ITEM(UIFlowWndPlay_StaticTXT_Speed)
CTRL_LIST_END

//----------------------UIFlowWndPlayCtrl Event---------------------------
INT32 UIFlowWndPlay_OnOpen(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyUp(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyDown(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyLeft(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyRight(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyZoomin(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyZoomout(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyMenu(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyDisplay(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyMode(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnChildClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnBattery(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyShutter2(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyEnter(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyPlayback(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnMovieFinish(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnMovieOneSec(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnStorageInit(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnStorageChange(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndPlay)
EVENT_ITEM(NVTEVT_OPEN_WINDOW,UIFlowWndPlay_OnOpen)
EVENT_ITEM(NVTEVT_CLOSE_WINDOW,UIFlowWndPlay_OnClose)
EVENT_ITEM(NVTEVT_KEY_UP,UIFlowWndPlay_OnKeyLeft)
EVENT_ITEM(NVTEVT_KEY_DOWN,UIFlowWndPlay_OnKeyRight)
//EVENT_ITEM(NVTEVT_KEY_LEFT,UIFlowWndPlay_OnKeyLeft)
//EVENT_ITEM(NVTEVT_KEY_RIGHT,UIFlowWndPlay_OnKeyRight)
EVENT_ITEM(NVTEVT_KEY_ZOOMIN,UIFlowWndPlay_OnKeyZoomin)
EVENT_ITEM(NVTEVT_KEY_ZOOMOUT,UIFlowWndPlay_OnKeyZoomout)
EVENT_ITEM(NVTEVT_KEY_MENU,UIFlowWndPlay_OnKeyMenu)
EVENT_ITEM(NVTEVT_KEY_DISPLAY,UIFlowWndPlay_OnKeyDisplay)
EVENT_ITEM(NVTEVT_KEY_MODE,UIFlowWndPlay_OnKeyMode)
EVENT_ITEM(NVTEVT_CHILD_CLOSE,UIFlowWndPlay_OnChildClose)
EVENT_ITEM(NVTEVT_BATTERY,UIFlowWndPlay_OnBattery)
EVENT_ITEM(NVTEVT_KEY_SHUTTER2,UIFlowWndPlay_OnKeyShutter2)
EVENT_ITEM(NVTEVT_KEY_ENTER,UIFlowWndPlay_OnKeyEnter)
EVENT_ITEM(NVTEVT_KEY_PLAYBACK,UIFlowWndPlay_OnKeyPlayback)
EVENT_ITEM(NVTEVT_CB_MOVIE_FINISH,UIFlowWndPlay_OnMovieFinish)
EVENT_ITEM(NVTEVT_CB_MOVIE_ONE_SEC,UIFlowWndPlay_OnMovieOneSec)
EVENT_ITEM(NVTEVT_STORAGE_INIT,UIFlowWndPlay_OnStorageInit)
EVENT_ITEM(NVTEVT_STORAGE_CHANGE,UIFlowWndPlay_OnStorageChange)
EVENT_END

static INT32 UIFlowWndPlay_OnExeUpKeyAct(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    switch(g_PlbData.State)
    {
        case PLB_ST_FULL:			
            if (UIPlay_GetData(PLAY_CURRMODE) == PLAYMODE_PRIMARY && UIPlay_GetData(PLAY_PBSTATUS) == PB_STA_DONE)
            {
                Ux_OpenWindow((VControl *)(&UIFlowWndPlayMagnifyCtrl), 0);
            }
            else if(UIPlay_GetData(PLAY_CURRMODE) == PLAYMODE_AVI)
            	{
	        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_NULL);
	        Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_PLAYNEXT,0);
	        FlowPB_UpdateIcons(1);
	        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_DEFAULT);

		}
            break;
        case PLB_ST_PLAY_MOV:
            if(!KeyScan_IsHDMIPlugIn())   //Not allow volume change when HDMI plugged in
            {
                if(g_uiUIFlowWndPlayCurrentVolume < AUDIO_VOL_7)
                {
                    g_uiUIFlowWndPlayCurrentVolume++;
                    Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_AUD_VOLUME,1,g_uiUIFlowWndPlayCurrentVolume);
                    FlowPB_IconDrawMovPlayVolumn(g_uiUIFlowWndPlayCurrentVolume);
                }
            }
            break;
			
        case PLB_ST_PAUSE_MOV:
            Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_MOVSTOP,0);
            g_PlbData.State = PLB_ST_FULL;
            g_PlbData.VideoPBSpeed = PLB_FWD_MOV_1x;
            hdmitx_setAudMute(FALSE);
            KeyScan_EnableAutoPoweroff(TRUE);
            KeyScan_EnableUSBDet(TRUE);
            KeyScan_EnableKeyTone(SysGetFlag(FL_BEEP));
//            KeyScan_EnableKeyTone(GetSysF(Get_BeepIndex()));
            FlowPB_UpdateIcons(1);
            /* reset original volume for key sound */
            Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_AUD_VOLUME,1,g_uiUIFlowWndPlayCurrentVolume);

        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_NULL);
        Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_PLAYNEXT,0);
        FlowPB_UpdateIcons(1);
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_DEFAULT);
		
        break;
    }
    return NVTEVT_CONSUME;
}

static INT32 UIFlowWndPlay_OnExeDownKeyAct(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32 uiActKey;

    if (paramNum >= 1)
        uiActKey = paramArray[0];

    switch (uiActKey)
    {
      case NVTEVT_KEY_PRESS:
           switch(g_PlbData.State)
            {
                case PLB_ST_FULL:
                    Ux_OpenWindow((VControl *)(&UIFlowWndPlayThumbCtrl), 0);
                    break;
                case PLB_ST_PLAY_MOV:
                    if(!KeyScan_IsHDMIPlugIn())   //Not allow volume change when HDMI plugged in
                    {
                        if(g_uiUIFlowWndPlayCurrentVolume > AUDIO_VOL_MUTE)
                        {
                            g_uiUIFlowWndPlayCurrentVolume--;
                            Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_AUD_VOLUME,1,g_uiUIFlowWndPlayCurrentVolume);
                            FlowPB_IconDrawMovPlayVolumn(g_uiUIFlowWndPlayCurrentVolume);
                        }
                    }
                    break;
			
	        case PLB_ST_PAUSE_MOV:
	            Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_MOVSTOP,0);
	            g_PlbData.State = PLB_ST_FULL;
	            g_PlbData.VideoPBSpeed = PLB_FWD_MOV_1x;
	            hdmitx_setAudMute(FALSE);
	            KeyScan_EnableAutoPoweroff(TRUE);
	            KeyScan_EnableUSBDet(TRUE);
	            KeyScan_EnableKeyTone(SysGetFlag(FL_BEEP));
	//            KeyScan_EnableKeyTone(GetSysF(Get_BeepIndex()));
	            FlowPB_UpdateIcons(1);
	            /* reset original volume for key sound */
	            Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_AUD_VOLUME,1,g_uiUIFlowWndPlayCurrentVolume);

	            Ux_OpenWindow((VControl *)(&UIFlowWndPlayThumbCtrl), 0);	
	        break;
		
            }
        break;
    }
    return NVTEVT_CONSUME;
}

INT32 UIFlowWndPlay_OnOpen(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    g_bUIFlowWndPlayNoImgWndOpened = FALSE;

    if (UIPlay_GetData(PLAY_FILENUM)==0)
    {
        Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,FLOWWRNMSG_ISSUE_NO_FILE,FLOWWRNMSG_TIMER_KEEP);
        g_bUIFlowWndPlayNoImgWndOpened = TRUE;
    }
    else
    {
        g_PlbData.VideoPBSpeed=PLB_FWD_MOV_1x;
        g_PlbData.State = PLB_ST_FULL;
        FlowPB_UpdateIcons(1);
    }
    // Turn on LCD backlight if TV is un plugged
    if (GPIOMap_IsLCDBacklightOn() == FALSE &&
        KeyScan_IsTVPlugIn() == FALSE &&
        KeyScan_IsHDMIPlugIn() == FALSE)
    {
        GPIOMap_TurnOnLCDBacklight();
    }	
    // set mask key
    Ux_FlushEvent();
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, PLAY_KEY_PRESS_MASK);
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, PLAY_KEY_RELEASE_MASK);
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_CONTINUE, PLAY_KEY_CONTINUE_MASK);

    Ux_DefaultEvent(pCtrl,NVTEVT_OPEN_WINDOW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    KeyScan_EnableAutoPoweroff(TRUE);
    KeyScan_EnableUSBDet(TRUE);
    KeyScan_EnableKeyTone(SysGetFlag(FL_BEEP));
    g_PlbData.VideoPBSpeed=PLB_FWD_MOV_1x;
    Ux_DefaultEvent(pCtrl,NVTEVT_CLOSE_WINDOW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnKeyUp(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndPlay_OnExeUpKeyAct(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndPlay_OnKeyDown(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndPlay_OnExeDownKeyAct(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndPlay_OnKeyLeft(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 uiActKey;

    if (paramNum >= 1)
        uiActKey = paramArray[0];

    switch (uiActKey)
    {
      case NVTEVT_KEY_PRESS:
        
    switch(g_PlbData.State)
    {
    case PLB_ST_FULL:
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_NULL);
        Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_PLAYPREV,0);
        FlowPB_UpdateIcons(1);
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_DEFAULT);
        break;

        case PLB_ST_PLAY_MOV:
        case PLB_ST_FWD_MOV:
        case PLB_ST_BWD_MOV:
        #if 0
        if(!KeyScan_IsHDMIPlugIn())   //Not allow volume change when HDMI plugged in
            {
                if(g_uiUIFlowWndPlayCurrentVolume < AUDIO_VOL_7)
                {
                    g_uiUIFlowWndPlayCurrentVolume++;
                    Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_AUD_VOLUME,1,g_uiUIFlowWndPlayCurrentVolume);
                    FlowPB_IconDrawMovPlayVolumn(g_uiUIFlowWndPlayCurrentVolume);
                }
            }
    #endif
            //if (KeyScan_IsHDMIPlugIn()==FALSE) {
                if(g_PlbData.VideoPBSpeed > PLB_BWD_MOV_8x)
                {
                    g_PlbData.VideoPBSpeed --;

                    Ux_FlushEvent();
                    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_NULL);

                    if(g_PlbData.VideoPBSpeed > PLB_FWD_MOV_1x)
                    {
                        Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_MOVFWD,1,g_PlbData.VideoPBSpeed);
                        g_PlbData.State = PLB_ST_FWD_MOV;
                        // set mute in FWD playing
                        hdmitx_setAudMute(TRUE);
                    }
                    else if(g_PlbData.VideoPBSpeed < PLB_FWD_MOV_1x)
                    {
                        Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_MOVBWD,1,g_PlbData.VideoPBSpeed);
                        g_PlbData.State = PLB_ST_BWD_MOV;
                        // set mute in BWD playing
                        hdmitx_setAudMute(TRUE);
                    }
                    else   //uiCurrSpeedIndex == PLAYMOV_SPEED_FWD_1X
                    {
                        Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_MOVFWDSTOP,0);
                        g_PlbData.State = PLB_ST_PLAY_MOV;
                        // Since Media FWD/BWD will set volume mute, we should restore current volume. 
                        hdmitx_setAudMute(FALSE);
//                        aud_setVolume(AUDIO_VOL_MUTE);
                        Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_AUD_VOLUME,1,g_uiUIFlowWndPlayCurrentVolume);
                    }

                    FlowPB_IconDrawMovSpeed();
                    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_DEFAULT);
                }
            //}
            break;
    }
    break;
        }
    return NVTEVT_CONSUME;
}

INT32 UIFlowWndPlay_OnKeyRight(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
UINT32 uiActKey;

    if (paramNum >= 1)
        uiActKey = paramArray[0];

    switch (uiActKey)
    {
      case NVTEVT_KEY_PRESS:
    switch(g_PlbData.State)
    {
    case PLB_ST_FULL:
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_NULL);
        Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_PLAYNEXT,0);
        FlowPB_UpdateIcons(1);
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_DEFAULT);
        break;
    case PLB_ST_PLAY_MOV:
    case PLB_ST_FWD_MOV:
    case PLB_ST_BWD_MOV:
    #if 0
        if(!KeyScan_IsHDMIPlugIn())   //Not allow volume change when HDMI plugged in
                    {
                     //debug_err(("henry--------------down\r\n"));
                        if(g_uiUIFlowWndPlayCurrentVolume > AUDIO_VOL_MUTE)
                        {
                            g_uiUIFlowWndPlayCurrentVolume--;
                            Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_AUD_VOLUME,1,g_uiUIFlowWndPlayCurrentVolume);
                            FlowPB_IconDrawMovPlayVolumn(g_uiUIFlowWndPlayCurrentVolume);
                        }
                    }
    #endif
      //if (KeyScan_IsHDMIPlugIn()==FALSE) {
            if(g_PlbData.VideoPBSpeed < PLB_FWD_MOV_8x)
            {
                g_PlbData.VideoPBSpeed ++;

                Ux_FlushEvent();
                KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_NULL);

                if(g_PlbData.VideoPBSpeed > PLB_FWD_MOV_1x)
                {
                    Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_MOVFWD,1,g_PlbData.VideoPBSpeed);
                    g_PlbData.State = PLB_ST_FWD_MOV;
                    // set mute in FWD playing
                    hdmitx_setAudMute(TRUE);
                }
                else if(g_PlbData.VideoPBSpeed < PLB_FWD_MOV_1x)
                {
                    Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_MOVBWD,1,g_PlbData.VideoPBSpeed);
                    g_PlbData.State = PLB_ST_BWD_MOV;
                    // set mute in BWD playing
                    hdmitx_setAudMute(TRUE);
                }
                else   //uiCurrSpeedIndex == PLAYMOV_SPEED_FWD_1X
                {
                    Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_MOVFWDSTOP,0);
                    g_PlbData.State = PLB_ST_PLAY_MOV;
                    
                    hdmitx_setAudMute(FALSE);
                    Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_AUD_VOLUME,1,g_uiUIFlowWndPlayCurrentVolume);
                }

                FlowPB_IconDrawMovSpeed();
                KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_DEFAULT);
            }
        //}
        break;
    }
    break;
        }
    return NVTEVT_CONSUME;
}

INT32 UIFlowWndPlay_OnKeyZoomin(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    switch(g_PlbData.State)
    {
    case PLB_ST_FULL:
        if (UIPlay_GetData(PLAY_CURRMODE) == PLAYMODE_PRIMARY)
        {
            g_PlbData.State = PLB_ST_MAGNIFY;
            Ux_OpenWindow((VControl *)(&UIFlowWndPlayMagnifyCtrl), 0);
        }
        break;
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnKeyZoomout(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    switch(g_PlbData.State)
    {
    case PLB_ST_FULL:
        g_PlbData.State = PLB_ST_THUMB;
        FlowPB_UpdateIcons(0);
        Ux_Redraw();
        Ux_OpenWindow((VControl *)(&UIFlowWndPlayThumbCtrl), 0);
        break;
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnKeyMenu(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

    switch(g_PlbData.State)
    {
    case PLB_ST_FULL:
        g_PlbData.State = PLB_ST_MENU;
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, FLGKEY_KEY_MASK_NULL);
        // Reset specific menu items
        SysSetFlag(FL_PROTECT, PROTECT_ONE);
        // Set Tab menu to Playback menu
        TM_SetMenu(&gPlaybackMenu);
        // Open common item menu
        Ux_OpenWindow(&MenuCommonItemCtrl, 0);
        break;
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnKeyDisplay(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;

    uiKeyAct = paramArray[0];

    switch(uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
        Ux_SendEvent(&UISystemObjCtrl,NVTEVT_EXE_DISPLAY,1,DISPLAY_NORMAL);
    break;
    }
    return NVTEVT_CONSUME;
}

INT32 UIFlowWndPlay_OnKeyMode(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    if (KeyScan_IsHDMIPlugIn()==TRUE)
        return NVTEVT_CONSUME;

    switch(g_PlbData.State)
    {
      case PLB_ST_PLAY_MOV:
      case PLB_ST_FWD_MOV:
      case PLB_ST_BWD_MOV:
        break;

        case PLB_ST_PAUSE_MOV:
            Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_MOVSTOP,0);
            g_PlbData.State = PLB_ST_FULL;
            g_PlbData.VideoPBSpeed = PLB_FWD_MOV_1x;
            hdmitx_setAudMute(FALSE);
            KeyScan_EnableAutoPoweroff(TRUE);
            KeyScan_EnableUSBDet(TRUE);
            KeyScan_EnableKeyTone(SysGetFlag(FL_BEEP));
//            KeyScan_EnableKeyTone(GetSysF(Get_BeepIndex()));
            FlowPB_UpdateIcons(1);
            /* reset original volume for key sound */
            Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_AUD_VOLUME,1,g_uiUIFlowWndPlayCurrentVolume);
            break;				
      case PLB_ST_FULL:
        Ux_FlushEvent();
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_NULL);
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, FLGKEY_KEY_MASK_NULL);
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_CONTINUE, FLGKEY_KEY_MASK_NULL);
        Ux_SendEvent(&UISystemObjCtrl,NVTEVT_CHANGE_DSCMODE,1,DSCMODE_CHGTO_NEXT);
        break;
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnChildClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

    if(paramNum > 0)
    {
        //Return from thumbnail, magnify or delete mode and play current image again.
        switch(paramArray[0])
        {
        case NVTRET_THUMBNAIL:
        case NVTRET_MAGNIFY:
            Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_PLAYCURR,0);
            FlowPB_UpdateIcons(1);
            break;
        case NVTRET_DELETE:
        case NVTRET_DELETEALL:
            if(UIPlay_GetData(PLAY_FILENUM)==0)
            {
                if(!g_bUIFlowWndPlayNoImgWndOpened)
                {
                    Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,FLOWWRNMSG_ISSUE_NO_IMAGE,FLOWWRNMSG_TIMER_KEEP);
                    g_bUIFlowWndPlayNoImgWndOpened = TRUE;
                }
            }
            else
            {
                Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_PLAYCURR,0);
                FlowPB_UpdateIcons(1);
            }
            break;
        case NVTRET_ENTER_MENU:
            // Reset specific menu items
            SysSetFlag(FL_PROTECT, PROTECT_ONE);
            // Set Tab menu to Playback menu
            TM_SetMenu(&gPlaybackMenu);
            // Open common item menu
            Ux_OpenWindow(&MenuCommonItemCtrl, 0);
            g_bUIFlowWndPlayNoImgWndOpened = FALSE;
            break;
        }
    }
    else
    {
        if(UIPlay_GetData(PLAY_FILENUM)==0)
        {
            if(!g_bUIFlowWndPlayNoImgWndOpened)
            {
                Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,FLOWWRNMSG_ISSUE_NO_IMAGE,FLOWWRNMSG_TIMER_KEEP);
                g_bUIFlowWndPlayNoImgWndOpened = TRUE;
            }
        }
        else
        {
            Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_PLAYCURR,0);
            FlowPB_UpdateIcons(1);
        }
    }
    g_PlbData.State = PLB_ST_FULL;

    KeyScan_EnableAutoPoweroff(TRUE);
    KeyScan_EnableUSBDet(TRUE);
    KeyScan_EnableKeyTone(SysGetFlag(FL_BEEP));

    // set mask key
    Ux_FlushEvent();
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, PLAY_KEY_PRESS_MASK);
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, PLAY_KEY_RELEASE_MASK);
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_CONTINUE, PLAY_KEY_CONTINUE_MASK);

    Ux_DefaultEvent(pCtrl,NVTEVT_CHILD_CLOSE,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnBattery(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
  //static volatile BOOL bBatteryOn = FALSE;

    UxState_SetData(&UIFlowWndPlay_StatusICN_BatteryCtrl,STATE_CURITEM,GetBatteryLevel());
    if (KeyScan_IsUSBPower())
    {
        //bBatteryOn = !bBatteryOn;
        UxCtrl_SetShow(&UIFlowWndPlay_StatusICN_BatteryCtrl,TRUE);
    } else {
        UxCtrl_SetShow(&UIFlowWndPlay_StatusICN_BatteryCtrl,TRUE);
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnKeyShutter2(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if 0
    switch(g_PlbData.State)
    {
        case PLB_ST_PLAY_MOV:
        case PLB_ST_PAUSE_MOV:
        case PLB_ST_FWD_MOV:
        case PLB_ST_BWD_MOV:
            Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_MOVSTOP,0);
            g_PlbData.State = PLB_ST_FULL;
            KeyScan_EnableAutoPoweroff(TRUE);
            KeyScan_EnableUSBDet(TRUE);
//            KeyScan_EnableKeyTone(GetSysF(Get_BeepIndex()));
            FlowPB_UpdateIcons(1);
            /* reset original volume for key sound */
//            Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_AUD_VOLUME,1,Get_VolumeValue(Get_VolumeIndex()));
            break;
    }
#endif
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnKeyEnter(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
  static BOOL bFirstEnter = TRUE;

    switch(g_PlbData.State)
    {
    case PLB_ST_FULL:
        if(UIPlay_GetData(PLAY_CURRMODE)==PLAYMODE_AVI)
        {
            if(bFirstEnter)
            {
                g_uiUIFlowWndPlayCurrentVolume = GetAudioVolume();
                bFirstEnter = FALSE;
            }
            KeyScan_EnableAutoPoweroff(FALSE);
            KeyScan_EnableUSBDet(FALSE);
            KeyScan_EnableKeyTone(FALSE);
            Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_AUD_VOLUME,1,g_uiUIFlowWndPlayCurrentVolume);
            Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_MOVPLAY,1,UIFlowMoviePlayCBFunc);
            g_PlbData.State = PLB_ST_PLAY_MOV;
            FlowPB_IconDrawMovPlay(TRUE);
            if (KeyScan_IsHDMIPlugIn()==FALSE)
            {
                FlowPB_IconDrawMovPlayVolumn(g_uiUIFlowWndPlayCurrentVolume);
            }
            FlowPB_IconDrawMovSpeed(0);
        }
        break;
    case PLB_ST_PLAY_MOV:
    case PLB_ST_FWD_MOV:
    case PLB_ST_BWD_MOV:
        if(UIPlay_GetData(PLAY_CURRMODE)==PLAYMODE_AVI)
        {
            Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_MOVPAUSE,0);
            g_PlbData.State = PLB_ST_PAUSE_MOV;
            KeyScan_EnableAutoPoweroff(TRUE);
            KeyScan_EnableUSBDet(TRUE);
            KeyScan_EnableKeyTone(SysGetFlag(FL_BEEP));
            FlowPB_IconDrawMovPlay(TRUE);
            FlowPB_IconDrawMovSpeed(0);
        }
        break;
    case PLB_ST_PAUSE_MOV:
        if(UIPlay_GetData(PLAY_CURRMODE)==PLAYMODE_AVI)
        {
            KeyScan_EnableAutoPoweroff(FALSE);
            KeyScan_EnableUSBDet(FALSE);
            KeyScan_EnableKeyTone(FALSE);
            Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_MOVRESUME,0);
            g_PlbData.State = PLB_ST_PLAY_MOV;
            FlowPB_IconDrawMovPlay(TRUE);
            FlowPB_IconDrawMovSpeed(0);
        }
        break;
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnKeyPlayback(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

    switch(g_PlbData.State)
    {
        case PLB_ST_FULL:
            if (KeyScan_IsHDMIPlugIn()==FALSE)
            {
                Ux_FlushEvent();
                KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_NULL);
                KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, FLGKEY_KEY_MASK_NULL);
                KeyScan_SetKeyMask(KEYSCAN_KEYMODE_CONTINUE, FLGKEY_KEY_MASK_NULL);
                Ux_SendEvent(&UISystemObjCtrl,NVTEVT_CHANGE_DSCMODE,1,DSCMODE_CHGTO_NEXT);
            }
            break;

        case PLB_ST_PLAY_MOV:
        case PLB_ST_PAUSE_MOV:
        case PLB_ST_FWD_MOV:
        case PLB_ST_BWD_MOV:
            Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_MOVSTOP,0);
            g_PlbData.State = PLB_ST_FULL;
            g_PlbData.VideoPBSpeed = PLB_FWD_MOV_1x;
            hdmitx_setAudMute(FALSE);
            KeyScan_EnableAutoPoweroff(TRUE);
            KeyScan_EnableUSBDet(TRUE);
            KeyScan_EnableKeyTone(SysGetFlag(FL_BEEP));
//            KeyScan_EnableKeyTone(GetSysF(Get_BeepIndex()));
            FlowPB_UpdateIcons(1);
            /* reset original volume for key sound */
            Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_AUD_VOLUME,1,g_uiUIFlowWndPlayCurrentVolume);
            break;

    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnMovieFinish(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_MOVSTOP,0);
    g_PlbData.State = PLB_ST_FULL;
    g_PlbData.VideoPBSpeed=PLB_FWD_MOV_1x;
    hdmitx_setAudMute(FALSE);
    KeyScan_EnableAutoPoweroff(TRUE);
    KeyScan_EnableUSBDet(TRUE);
    KeyScan_EnableKeyTone(SysGetFlag(FL_BEEP));
    Ux_SendEvent(&UIPlayObjCtrl,NVTEVT_AUD_VOLUME,1,g_uiUIFlowWndPlayCurrentVolume);
    FlowPB_UpdateIcons(1);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnMovieOneSec(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    FlowPB_IconDrawMovPlayTime(TRUE);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnStorageInit(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnStorageChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
//----------------------UIFlowWndPlay_StaticICN_DSCModeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StaticICN_DSCMode)
EVENT_END

//----------------------UIFlowWndPlay_StatusICN_FlashCtrl Event---------------------------
INT32 UIFlowWndPlay_StatusICN_Flash_OnKeyRight(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndPlay_StatusICN_Flash)
EVENT_ITEM(NVTEVT_KEY_RIGHT,UIFlowWndPlay_StatusICN_Flash_OnKeyRight)
EVENT_END

INT32 UIFlowWndPlay_StatusICN_Flash_OnKeyRight(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_SendEvent(pCtrl,NVTEVT_NEXT_ITEM,0);
    return NVTEVT_CONSUME;
}
//----------------------UIFlowWndPlay_StatusICN_EVCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StatusICN_EV)
EVENT_END

//----------------------UIFlowWndPlay_StaticTXT_SizeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StaticTXT_Size)
EVENT_END

//----------------------UIFlowWndPlay_StatusICN_WBCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StatusICN_WB)
EVENT_END

//----------------------UIFlowWndPlay_StatusICN_QualityCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StatusICN_Quality)
EVENT_END

//----------------------UIFlowWndPlay_StatusICN_SharpnessCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StatusICN_Sharpness)
EVENT_END

//----------------------UIFlowWndPlay_StatusICN_StorageCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StatusICN_Storage)
EVENT_END

//----------------------UIFlowWndPlay_StatusICN_BatteryCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StatusICN_Battery)
EVENT_END

//----------------------UIFlowWndPlay_TabHistogramCtrl Event---------------------------
INT32 UIFlowWndPlay_TabHistogram_OnRedraw(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndPlay_TabHistogram)
EVENT_ITEM(NVTEVT_REDRAW,UIFlowWndPlay_TabHistogram_OnRedraw)
EVENT_END

INT32 UIFlowWndPlay_TabHistogram_OnRedraw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_DefaultEvent(pCtrl,NVTEVT_REDRAW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
//----------------------UIFlowWndPlay_StaticTXT_FilenameCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StaticTXT_Filename)
EVENT_END

//----------------------UIFlowWndPlay_StaticICN_ProtectCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StaticICN_Protect)
EVENT_END

//----------------------UIFlowWndPlay_StaticTXT_DateCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StaticTXT_Date)
EVENT_END

//----------------------UIFlowWndPlay_StaticTXT_TimeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StaticTXT_Time)
EVENT_END

//----------------------UIFlowWndPlay_HistoCtrl Event---------------------------
INT32 UIFlowWndPlay_Histo_OnRedraw(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndPlay_Histo)
EVENT_ITEM(NVTEVT_REDRAW,UIFlowWndPlay_Histo_OnRedraw)
EVENT_END

INT32 UIFlowWndPlay_Histo_OnRedraw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
//----------------------UIFlowWndPlay_StatusICN_MovPlayCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StatusICN_MovPlay)
EVENT_END

//----------------------UIFlowWndPlay_StatusICN_MovStopCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StatusICN_MovStop)
EVENT_END

//----------------------UIFlowWndPlay_StatusICN_MovBwdCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StatusICN_MovBwd)
EVENT_END

//----------------------UIFlowWndPlay_StaticTXT_MovPlayTimeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StaticTXT_MovPlayTime)
EVENT_END

//----------------------UIFlowWndPlay_StatusICN_MovFwdCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StatusICN_MovFwd)
EVENT_END

//----------------------UIFlowWndPlay_StatusICN_VolumnCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StatusICN_Volumn)
EVENT_END

//----------------------UIFlowWndPlay_StaticICN_PrintCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StaticICN_Print)
EVENT_END

//----------------------UIFlowWndPlay_StaticTXT_SpeedCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StaticTXT_Speed)
EVENT_END

