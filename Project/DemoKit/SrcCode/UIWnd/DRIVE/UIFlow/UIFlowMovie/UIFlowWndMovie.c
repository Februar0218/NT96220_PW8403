//This source code is generated by UI Designer Studio.

#include "UIFramework.h"
#include "UIFrameworkExt.h"
#include "NVTToolCommand.h"
#include "UIFlowWndMovieRes.c"
#include "UIFlow.h"
#include "KeyScanTsk.h"
#include "PrimaryTsk.h"
#include "Gsensor.h"
#include "GPS.h"
#include "SystemInit.h"
#include "VoltageDet.h"

//---------------------UIFlowWndMovieCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_camera)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_CyclicRec)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_MotionDet)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_battery)
CTRL_LIST_ITEM(UIFlowWndMovie_YMD_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_HMS_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_Panel)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Storage)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_time)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_maxtime)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_resolution)
CTRL_LIST_ITEM(UIFlowWndMovie_Zoom_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_EV)
//CTRL_LIST_ITEM(UIFlowWndMovie_Status_LedLight)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_MovieAudio)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_LOCK)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_GPS)
CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_Parking)
CTRL_LIST_ITEM(UIFlowWndMovie_PanelYellow)
//CTRL_LIST_ITEM(UIFlowWndMovie_CarNo_Static)
//CTRL_LIST_ITEM(UIFlowWndMovie_Status_ZHCarNo)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_GSENSOR)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_SHRINK)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_DAOCHE)
CTRL_LIST_END

//----------------------UIFlowWndMovieCtrl Event---------------------------
INT32 UIFlowWndMovie_OnOpen(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyMenu(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyEnter(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyDown(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyRight(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyLeft(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnChildClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyShutter2(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyZoomin(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyZoomout(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyUp(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyPlayBack(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyDisplay(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnBattery(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyMode(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieFinish(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieOneSec(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieFull(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieWrError(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnPreviewStable(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnOZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnDZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnTimer(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnRecEventSlow(VControl *, UINT32, UINT32 *);

EVENT_BEGIN(UIFlowWndMovie)
EVENT_ITEM(NVTEVT_OPEN_WINDOW,UIFlowWndMovie_OnOpen)
EVENT_ITEM(NVTEVT_CLOSE_WINDOW,UIFlowWndMovie_OnClose)
EVENT_ITEM(NVTEVT_KEY_MENU,UIFlowWndMovie_OnKeyMenu)
EVENT_ITEM(NVTEVT_KEY_ENTER,UIFlowWndMovie_OnKeyEnter)
EVENT_ITEM(NVTEVT_KEY_DOWN,UIFlowWndMovie_OnKeyDown)
//EVENT_ITEM(NVTEVT_KEY_LEFT,UIFlowWndMovie_OnKeyLeft)
EVENT_ITEM(NVTEVT_KEY_LEDCTR,UIFlowWndMovie_OnKeyLeft)
EVENT_ITEM(NVTEVT_KEY_RIGHT,UIFlowWndMovie_OnKeyRight)
EVENT_ITEM(NVTEVT_CHILD_CLOSE,UIFlowWndMovie_OnChildClose)
EVENT_ITEM(NVTEVT_KEY_SHUTTER2,UIFlowWndMovie_OnKeyShutter2)
EVENT_ITEM(NVTEVT_KEY_ZOOMIN,UIFlowWndMovie_OnKeyZoomin)
EVENT_ITEM(NVTEVT_KEY_ZOOMOUT,UIFlowWndMovie_OnKeyZoomout)
EVENT_ITEM(NVTEVT_KEY_UP,UIFlowWndMovie_OnKeyUp)
EVENT_ITEM(NVTEVT_KEY_PLAYBACK,UIFlowWndMovie_OnKeyPlayBack)
EVENT_ITEM(NVTEVT_KEY_DISPLAY,UIFlowWndMovie_OnKeyDisplay)
EVENT_ITEM(NVTEVT_BATTERY,UIFlowWndMovie_OnBattery)
EVENT_ITEM(NVTEVT_KEY_MODE,UIFlowWndMovie_OnKeyMode)
EVENT_ITEM(NVTEVT_CB_MOVIE_FINISH,UIFlowWndMovie_OnMovieFinish)
EVENT_ITEM(NVTEVT_CB_MOVIE_ONE_SEC,UIFlowWndMovie_OnMovieOneSec)
EVENT_ITEM(NVTEVT_CB_MOVIE_FULL,UIFlowWndMovie_OnMovieFull)
EVENT_ITEM(NVTEVT_CB_MOVIE_WR_ERROR,UIFlowWndMovie_OnMovieWrError)
EVENT_ITEM(NVTEVT_CB_PREVIEWSTABLE,UIFlowWndMovie_OnPreviewStable)
EVENT_ITEM(NVTEVT_CB_OZOOMSTEPCHG,UIFlowWndMovie_OnOZoomStepChange)
EVENT_ITEM(NVTEVT_CB_DZOOMSTEPCHG,UIFlowWndMovie_OnDZoomStepChange)
EVENT_ITEM(NVTEVT_STORAGE_CHANGE,UIFlowWndMovie_OnStorageChange)
EVENT_ITEM(NVTEVT_TIMER,UIFlowWndMovie_OnTimer)
EVENT_ITEM(NVTEVT_KEY_CUSTOM2,UIFlowWndMovie_OnRecEventSlow)

EVENT_END


// Movie mode key mask
#define MOVIE_KEY_PRESS_MASK        (FLGKEY_KEY_MASK_DEFAULT)
#define MOVIE_KEY_RELEASE_MASK      (FLGKEY_UP | FLGKEY_DOWN)
#define MOVIE_KEY_CONTINUE_MASK     (FLGKEY_UP | FLGKEY_DOWN | FLGKEY_ENTER | FLGKEY_MODE)
#define MOVIERECORD_KEY_PRESS_MASK  (FLGKEY_UP | FLGKEY_DOWN | FLGKEY_ENTER | FLGKEY_MODE)
//-----------------------------------------------------------------------------------------
static BOOL    g_uiRecordIngMotionDet = FALSE;
static UINT32  gUIMotionDetTimerID = TIMER_NULL;
static UINT32  g_uiDateTimerID = TIMER_NULL;
static UINT32 g_uiMaskKeyPress      = MOVIE_KEY_PRESS_MASK;
static UINT32 g_uiMaskKeyRelease    = MOVIE_KEY_RELEASE_MASK;
static UINT32 g_uiMaskKeyContinue   = MOVIE_KEY_CONTINUE_MASK;
static volatile BOOL g_bRedLEDOn = FALSE;
BOOL g_bSpeLockFun = FALSE;
BOOL gbMoviFileLock = FALSE;
BOOL g_bSOSMoiveLock_Next = FALSE;
BOOL g_bNextLoop = FALSE;
static UINT32 uiAVICurrentSec = 0;
static BOOL gbDoFileProtect = FALSE;
extern BOOL bUSBUnplug;
extern BOOL gStarSOSDet;
extern volatile BOOL g_formatcard;
__align(4)  GPSDATA gpsdata={0};

static volatile UINT32   uiBatteryLvl           = VOLDET_BATTERY_LVL_3;

BOOL uiDelayShutterKey = FALSE;
static UINT32 uiDelayShutterKeynt = 0;
#if 1
void KeyScan_DelayShutterKey(void)
{    
    //debug_msg("^R uiDelayShutterKeynt == %d",uiDelayShutterKeynt);
    //debug_msg("^R uiDelayShutterKey == %d",uiDelayShutterKey);

    if (uiDelayShutterKey == TRUE)
    {
        uiDelayShutterKeynt++;
        if(uiDelayShutterKeynt >= 3)
        {
            uiDelayShutterKey = FALSE;
            uiDelayShutterKeynt = 0;
        }
    }
}
#endif
static UINT32 FlowMovie_CheckMemoryForCyclicRec(UINT32 uiCyclicRecTime)
{
    UH      uhDirID = 1, uhFileID = 1;
    UINT32  err;

    debug_err(("uiCyclicRecTime : %d Movie Maxsecond : %d\r\n",uiCyclicRecTime,UIRecMovie_GetData(RECMOVIE_MAXSECOND)));

    while (uiCyclicRecTime >= (2*UIRecMovie_GetData(RECMOVIE_MAXSECOND)+30))
    {
        // always get oldest (1st) DCF file
        FilesysWaitInitFinish(FST_TIME_INFINITE);
        FilesysWaitCmdFinish(FST_TIME_INFINITE);
        err = FilesysGetDCFIDBySeq(1, &uhDirID, &uhFileID);
        FilesysWaitCmdFinish(FST_TIME_INFINITE);

        // check if there is no DCF file then stop
        if (uhDirID == 0 && uhFileID == 0)
        {
            debug_err(("[Cyclic Rec]: No DCF file\r\n"));
            break;
        }

        // check if file is protected; if yes, unlock it
        FilesysSetFileLock(uhFileID, uhDirID, FALSE);
        FilesysWaitCmdFinish(FST_TIME_INFINITE);

        // erase file
        debug_err(("[Cyclic Rec]: Erase file: DirID = %d, FileID = %d\r\n", uhDirID, uhFileID));
        err = FilesysDeleteFile(uhDirID, uhFileID, FST_FMT_ANYFORMAT);
        FilesysWaitCmdFinish(FST_TIME_INFINITE);
    }

    if (uiCyclicRecTime > 2*UIRecMovie_GetData(RECMOVIE_MAXSECOND)) // still no enough space for recording one period
    {
        return FALSE;
    }

    return TRUE;
}


static void UIFlowWndMovie_Update_Speed(void)
{
    BOOL bS;
    RMCINFO RMCInfo;
    Gsensor_Data GS_Data;
    RTC_DATE        CurDate;
    RTC_TIME        CurTime;
    UINT32 szIQInfo;
    UINT32 GPSStatus;	
    static BOOL first = TRUE;
    static UINT32 uiGPSCounter = 0;
    static UINT32 i;	
    static UINT32 GPS_Second_Pre=0xff;
    uiGPSCounter++;
    #if (_GPS_RECEIVER_ == ENABLE)	
    //gsensor_GetData(&GS_Data);
    bS = GPSRec_GetRMCDate(&RMCInfo);
	
        memcpy(&(gpsdata.rmcinfo),&RMCInfo,sizeof(RMCINFO));
        memcpy(&(gpsdata.gs_data),&GS_Data,sizeof(Gsensor_Data));
	 debug_msg("%c,%d,%d\r\n",gpsdata.rmcinfo.Status,gpsdata.rmcinfo.Latitude,gpsdata.rmcinfo.Longitude);
//jack lan 
     //GPSStatus = (RMCInfo.Status  ^ RMCInfo.NSInd) & 0xff;  // GPSStatus 0: no fix, 1: 2D fix, 2: 3D fix
     
	if(GPSRec_CheckData() == TRUE)
	{
	      if(GPS_Second_Pre != RMCInfo.Second)
	      	{
	       i++;
		if((i%3)==1){
    		UxState_SetData(&UIFlowWndMovie_Status_GPSCtrl,STATE_CURITEM,UIFlowWndMovie_Status_GPS_ICON_GPS_LEVEL1);}	
		else if((i%3)==2){
    		UxState_SetData(&UIFlowWndMovie_Status_GPSCtrl,STATE_CURITEM,UIFlowWndMovie_Status_GPS_ICON_GPS_LEVEL2);}	
		else if((i%3)==0){
    		UxState_SetData(&UIFlowWndMovie_Status_GPSCtrl,STATE_CURITEM,UIFlowWndMovie_Status_GPS_ICON_GPS_LEVEL3);}						
		GPS_Second_Pre = RMCInfo.Second;			
	      	}
		else
		{
	    		UxState_SetData(&UIFlowWndMovie_Status_GPSCtrl,STATE_CURITEM,UIFlowWndMovie_Status_GPS_ICON_GPS_LEVEL0);			
		}		 
	}
	else
	{
    		UxState_SetData(&UIFlowWndMovie_Status_GPSCtrl,STATE_CURITEM,UIFlowWndMovie_Status_GPS_ICON_GPS_LEVEL0);			
	}
#else
        memset(&gpsdata,0,sizeof(GPSDATA));
#endif    
}

void UIFlowWndMovie_OnExeLockFile(BOOL En)
{
 debug_err(("------------gbMoviFileLock : %d-----------\r\n",En));	
	gbMoviFileLock = En;
}
INT32 UIFlowWndMovie_OnExeRecord(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32 uiKeyAct;
 UINT32 uiState,uiSlowCard=0;

    // flush key event first
    Ux_FlushEvent();

    if(GPIOMap_DetStrgCard() == FALSE)
    {
	  gMovData.State= MOV_ST_WARNING_MENU;
        Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_NO_CARD,FLOWWRNMSG_TIMER_2SEC);
        return NVTEVT_CONSUME;		
    }
    // do nothing while pluging HDMI
    if (KeyScan_IsHDMIPlugIn() == TRUE)
    {
        return NVTEVT_CONSUME;
    }

    if (GPIOMap_DetStrgCard() == FALSE)
    {
        Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD,FLOWWRNMSG_TIMER_2SEC);
        return NVTEVT_CONSUME;
    }

    if (paramNum>=3)
    {
        uiState = paramArray[2];
        if (paramNum>=4)
            uiSlowCard = paramArray[3];
    } else {
        uiState = 0;
    }

    uiKeyAct = paramArray[0];
     
    switch (uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
        switch (gMovData.State)
        {
        case MOV_ST_VIEW:
		debug_msg("MOV_ST_VIEW***********************************ERIC_DEBUG\n\r");//ERIC_DEBUG
            if (FlowMovie_IsStorageErr() == TRUE)
            {
                gMovData.State= MOV_ST_WARNING_MENU;
                gMovData.SysTimeCount = 0;
                return NVTEVT_CONSUME;
            }
            if (FlowMovie_GetSelfTimerID() != NULL_TIMER)
            {
                FlowMovie_StopRecSelfTimer();
                return NVTEVT_CONSUME;
            }
			
            if (SysGetFlag(FL_MOVIE_MOTION_DET)==MOVIE_MOTIONDET_ON)
            {
                g_uiRecordIngMotionDet = TRUE;
            } else {
                g_uiRecordIngMotionDet = FALSE;
            }
         
            uiDelayShutterKey = TRUE;
            FlowMovie_StartRec();
            break;
        case MOV_ST_REC:
        case MOV_ST_REC|MOV_ST_ZOOM:
            if (FlowMovie_GetRecCurrTime() >= 3)
            {
                FlowMovie_StopRec();
		  debug_msg("FlowMovie_StopRec***************FlowMovie_StopRec****************ERIC_DEBUG\n\r");//ERIC_DEBUG
		
                uiDelayShutterKey = TRUE;
                if (uiState==UIFlowWndMovie_Restart_Rec)
                {
                    //#NT#2012/9/25#Philex Lin - begin
                    // Set NR/TBR/FR parameters dynamically
                    #if (_MOVIE_SLOW_CARD_ == ENABLE)
                    if (uiSlowCard == UIFlowWndMovie_Restart_SlowCard)
                    {
                        if (FlowMovie_NeedHandleSlowCard())
                            FlowMovie_SlowCardHandling();
                    }
                    #endif
                    Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
                } else {
                    if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON)//henry 20141209
                    {
                        if (g_uiRecordIngMotionDet == TRUE)
                        {
                            g_uiRecordIngMotionDet = FALSE;
				 SysSetFlag(FL_MOVIE_MOTION_DET,MOVIE_MOTIONDET_OFF);						
                        }
                    }
                }
            }
            break;
        }
        break;
    }
    Ux_DefaultEvent(pCtrl,NVTEVT_KEY_SHUTTER2,paramNum,paramArray);
    return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnExeZoomIn(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32  state;

    if (paramNum > 0)
        state = *paramArray;
    debug_ind(("[UIFlowWndMovie_OnExeZoomIn][%d]\n\r",*paramArray));
    switch(state)
    {
    case NVTEVT_KEY_PRESS:
    case FLGKEY_HOLD:
        if ((Photo_GetDZoomIdx()-10) > UI_DZOOM_IDX_MAX)
        {
            Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_ZOOMSTOP,0);
            gMovData.State &= ~MOV_ST_ZOOM;
            return NVTEVT_PASS;
        }
        switch (gMovData.State)
        {
        case MOV_ST_VIEW:
        case MOV_ST_REC:
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
            gMovData.State |= MOV_ST_ZOOM;
            Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_ZOOMIN,0);
            break;
        }
        break;

    case NVTEVT_KEY_RELEASE:
        switch (gMovData.State)
        {
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
            Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_ZOOMSTOP,0);
            gMovData.State &= ~MOV_ST_ZOOM;
            break;
        }
        break;
    }
    return NVTEVT_PASS;
}

INT32 UIFlowWndMovie_OnExeZoomOut(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32  state;

    if (paramNum > 0)
        state = *paramArray;
    debug_ind(("[UIFlowWndMovie_OnExeZoomIn][%d]\n\r",*paramArray));
    switch(state)
    {
    case NVTEVT_KEY_PRESS:
    case FLGKEY_HOLD:
        switch (gMovData.State)
        {
        case MOV_ST_VIEW:
        case MOV_ST_REC:
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
             gMovData.State |= MOV_ST_ZOOM;
             Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_ZOOMOUT,0);
            break;
        }
        break;

    case NVTEVT_KEY_RELEASE:
        switch (gMovData.State)
        {
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
            Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_ZOOMSTOP,0);
            gMovData.State &= ~MOV_ST_ZOOM;
            break;
        }
        break;
    }
    return NVTEVT_PASS;
}

void UIFlowWndMovie_Initparam(void)
{
    // The same effect as Photo mode
    Ux_SendEvent(&UIPhotoObjCtrl,   NVTEVT_EXE_WB,              1,  SysGetFlag(FL_WB));

    // The other settings
    Ux_SendEvent(&UIMovieObjCtrl,   NVTEVT_EXE_COLOR,           1,  MOVIE_COLOR_NORMAL);

    /* Video resolution setting must be set after other IQ settings */
    Ux_SendEvent(&UIMovieObjCtrl,   NVTEVT_EXE_MOVIESIZE,       1,  SysGetFlag(FL_MOVIE_SIZE));//ERIC EDIT 0901
    Ux_SendEvent(&UIMovieObjCtrl, NVTEVT_EXE_MOVIETIMESHRINK, 1, SysGetFlag(FL_MOVIE_TIMESHRINK));//henry 20141216

    /* Cyclic recording/record with mute or sound/DateImptint/Motion Detect */
    Ux_SendEvent(&UIMovieObjCtrl,   NVTEVT_EXE_CYCLIC_REC,       1, SysGetFlag(FL_MOVIE_LOOP_REC));
    Ux_SendEvent(&UIMovieObjCtrl,   NVTEVT_EXE_MOTION_DET,       1, SysGetFlag(FL_MOVIE_MOTION_DET));
    Ux_SendEvent(&UIMovieObjCtrl,   NVTEVT_EXE_DATEIMPRINT,      1, SysGetFlag(FL_MOVIE_DATEIMPRINT));
    Ux_SendEvent(&UIMovieObjCtrl,   NVTEVT_EXE_VIDEO_AUDIO,      1, SysGetFlag(FL_MOVIE_AUDIO));
    Ux_SendEvent(&UIMovieObjCtrl,   NVTEVT_EXE_EV,               1, SysGetFlag(FL_MOVIE_EV));
}

INT32 UIFlowWndMovie_OnOpen(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_FlushEvent();
    /* Init window key mask variables & set key and key released mask */
    g_uiMaskKeyPress = MOVIE_KEY_PRESS_MASK;
    g_uiMaskKeyRelease = MOVIE_KEY_RELEASE_MASK;
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, g_uiMaskKeyRelease);
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_CONTINUE, g_uiMaskKeyContinue);

    FlowMovie_UpdateIcons(TRUE);

    if(UI_Validate_Storage(STORAGE_CHECK_ERROR, NULL) == FALSE)
    {
       Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD, FLOWWRNMSG_TIMER_KEEP);
    }
	if (g_formatcard == TRUE)
	{
	        g_formatcard = FALSE;
	        if (GPIOMap_DetStrgCard() == TRUE)
		 {
		 	Ux_BackgroundPostEvent(NVTEVT_BKW_FORMATCARD);	
			TimerDelayMs(1000);
		 }
	}
    // update g_uiRecordIngMotionDet flag
    if (gUIMotionDetTimerID==TIMER_NULL)
    {
        gUIMotionDetTimerID = KeyScan_startTimer(TIMER_HALF_SEC, NVTEVT_05SEC_TIMER, TIMER_TYPE_CONTINUE);
    }

    if (g_uiDateTimerID == TIMER_NULL)
    {
        g_uiDateTimerID = KeyScan_startTimer(TIMER_ONE_SEC, NVTEVT_1SEC_TIMER, TIMER_TYPE_CONTINUE);
    }
    gStarSOSDet = TRUE;

    #if (_GPS_RECEIVER_ == ENABLE)
    GPSRec_Open(UART_BAUDRATE_115200);
    #endif
 	if (SysGetFlag(FL_MOVIE_MOTION_DET)==MOVIE_MOTIONDET_ON)//henry20150204
            {
                g_uiRecordIngMotionDet = TRUE;
            } else {
                g_uiRecordIngMotionDet = FALSE;
            }
    Ux_DefaultEvent(pCtrl,NVTEVT_OPEN_WINDOW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    switch (gMovData.State)
    {
    case MOV_ST_REC:
        if (FlowMovie_GetRecCurrTime() <= 1)
        {
            TimerDelayMs(1000);
        }
        FlowMovie_StopRec();
        Ux_SendEvent(&UIFlowWndMovieCtrl,NVTEVT_CB_MOVIE_FINISH,0);
        break;
    }

    g_bRedLEDOn = FALSE;
    KeyScan_TurnOffLED(KEYSCAN_LED_RED);
//    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_DEFAULT);
//    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, FLGKEY_KEY_REL_MASK_DEFAULT);

    if (gUIMotionDetTimerID!=TIMER_NULL)
    {
        KeyScan_stopTimer(&gUIMotionDetTimerID);
    }

    if (g_uiDateTimerID != TIMER_NULL)
    {
        KeyScan_stopTimer(&g_uiDateTimerID);
    }

    Ux_DefaultEvent(pCtrl,NVTEVT_CLOSE_WINDOW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyMenu(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;

    uiKeyAct = paramArray[0];
   // if(GPIOMap_GetTVStatus() == TRUE)
        //return;
    //else
    {
    	switch(uiKeyAct)
    	{
    		case NVTEVT_KEY_PRESS:
        		switch(gMovData.State)
			{
				case MOV_ST_VIEW:
				case MOV_ST_VIEW|MOV_ST_ZOOM:
					KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, FLGKEY_KEY_MASK_NULL);
					// Set Tab menu to Photo menu
					TM_SetMenu(&gMovieMenu);
					// Open common mix (Item + Option) menu
					Ux_OpenWindow((VControl *)(&MenuCommonItemCtrl), 0);
					gMovData.State = MOV_ST_MENU;
					break;
				/*case MOV_ST_REC:
				case MOV_ST_REC|MOV_ST_ZOOM:
					Ux_SendEvent(&UIMovieObjCtrl, NVTEVT_EXE_VIDEO_AUDIO, 1, !SysGetFlag(FL_MOVIE_AUDIO));
					FlowMovie_IconDrawMovieAudio(&UIFlowWndMovie_Status_MovieAudioCtrl);	
					break;*/
					case MOV_ST_REC:
					case MOV_ST_REC|MOV_ST_ZOOM:
                                         FlowMovie_IconDrawLockFile();//ÏÔÊ¾LOGO
	                                  MediaRec_SetCrash();//¼ÓËø
	                               break;	
			}
        		break;
    	}
    }
    	Ux_DefaultEvent(pCtrl,NVTEVT_KEY_MENU,paramNum,paramArray);
    	return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyEnter(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    //uiBatteryLvl = VolDet_GetBatteryLevel();
    //if(uiBatteryLvl ==VOLDET_BATTERY_LVL_0)
    //{
        //TimerDelayMs(500);
        //uiBatteryLvl = VolDet_GetBatteryLevel();
    //}

    //return NVTEVT_CONSUME;
    //debug_msg("^R uiDelayShutterKey == %d",uiDelayShutterKey);
   // if((GPIOMap_GetTVStatus() == TRUE) ||(uiDelayShutterKey == TRUE))
    //if(uiDelayShutterKey == TRUE)
        //return;
    //else
    //{
        return UIFlowWndMovie_OnExeRecord(pCtrl,paramNum,paramArray);
		     
    //}
}

#define VIDEO_PATH_LEN 21
INT32 UIFlowWndMovie_OnKeyDown(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT16 uhFolderId = 0, uhFileId = 0;
	UINT32 uiKeyAct;
	UINT8 i;
       // UINT32 uiBreaklight2 = FALSE;

    	uiKeyAct = paramArray[0];

   // if(GPIOMap_GetTVStatus() == TRUE)
    //{
       // GPIOMap_TurnOnLCDBacklight();
        //return;
    //}
   // else
    {
       /* if(GPIOMap_GetTVStatus() == FALSE)
        {
            GPIOMap_TurnOffLCDBacklight();
            TimerDelayMs(500);
            uiBreaklight2 = TRUE;
        }*/
    	switch (uiKeyAct)
    	{
        	case NVTEVT_KEY_PRESS:
                  switch (gMovData.State)
		    {
		        /*case MOV_ST_VIEW:
		        case MOV_ST_VIEW | MOV_ST_ZOOM:
  			 //case MOV_ST_REC:
  			 //case MOV_ST_REC | MOV_ST_ZOOM:
                            if(uiBreaklight2 = TRUE)
                            {
                            for(i=0;i<VIDEO_PATH_LEN;i++)
                            {
                                I2C_TxByte (0x00,BIT1216M_CVBS_REG[i][0],BIT1216M_CVBS_REG[i][1]);	
                                //FlowMovie_IconDrawDaoche();
                            }
                                TimerDelayMs(500);
                                GPIOMap_TurnOnLCDBacklight();
                                TimerDelayMs(200);
                                GPIOMap_SetTV(TRUE);
                            }
                            break;*/
                      case MOV_ST_VIEW:
		        case MOV_ST_VIEW | MOV_ST_ZOOM:
  			 case MOV_ST_REC:
  			 case MOV_ST_REC | MOV_ST_ZOOM:
					Ux_SendEvent(&UIMovieObjCtrl, NVTEVT_EXE_VIDEO_AUDIO, 1, !SysGetFlag(FL_MOVIE_AUDIO));
					FlowMovie_IconDrawMovieAudio(&UIFlowWndMovie_Status_MovieAudioCtrl);	
					break;
		    }
                break;
    		}
    }	
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyLeft(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if 0
 UINT32  uiKeyAct;
 UINT32 uiEV;

   uiKeyAct = paramArray[0];

    switch(uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
         switch(gMovData.State)
         {
            case MOV_ST_VIEW:
            case MOV_ST_VIEW|MOV_ST_ZOOM:
                uiEV = SysGetFlag(FL_MOVIE_EV);
                if (uiEV==EV_N20)
                {
                    SysSetFlag(FL_MOVIE_EV,EV_P20);
                } else {
                    SysSetFlag(FL_MOVIE_EV,++uiEV);
                }
                Ux_SendEvent(&UIMovieObjCtrl,NVTEVT_EXE_EV,1, SysGetFlag(FL_MOVIE_EV));
                FlowMovie_IconDrawEV(&UIFlowWndMovie_StatusICN_EVCtrl);
            break;
            case MOV_ST_REC:
                if(SysGetFlag(FL_MOVIE_LOOP_REC) != MOVIE_CYCLICREC_OFF && FlowMovie_GetRecCurrTime() >= 1)
                {
                    #if( PRJ == APC3)
                        g_bSpeLockFun = TRUE;
                        FlowMovie_StopRec();
                        Ux_SendEvent(pCtrl,NVTEVT_CB_MOVIE_FINISH,1,UIFlowWndMovie_Restart_Rec);
                    #endif
                }
            break;
         }
        break;
    }

    return NVTEVT_CONSUME;
#else

 UINT32  uiKeyAct;
    UINT16 uhFolderId, uhFileId;

   uiKeyAct = paramArray[0];	
    switch(uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
	  Ux_SendEvent(&UIMovieObjCtrl, NVTEVT_EXE_LEDLIGHT, 0);
        FlowMovie_IconDrawLedLight(&UIFlowWndMovie_Status_LedLightCtrl);
	    	break;
    	}
	
    return NVTEVT_CONSUME;
    //return UIFlowWndPhoto_OnExeZoomOut(pCtrl, paramNum, paramArray);

#endif	
}
INT32 UIFlowWndMovie_OnKeyRight(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32  uiKeyAct;

   uiKeyAct = paramArray[0];

    switch (uiKeyAct)
    {
     case NVTEVT_KEY_PRESS:
        if (g_bRedLEDOn ==FALSE) {
            g_bRedLEDOn =TRUE;
            KeyScan_TurnOnLED(KEYSCAN_LED_RED);
        } else {
            g_bRedLEDOn = FALSE;
            KeyScan_TurnOffLED(KEYSCAN_LED_RED);
        }
        break;
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnChildClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    switch (gMovData.State)
    {
    case MOV_ST_WARNING_MENU:
         if(paramNum > 0)
            {
                if(paramArray[0] == NVTRET_ENTER_MENU)
                {
                    /* Create Menu window */
                    gMovData.State = MOV_ST_MENU;
                    TM_SetMenu(&gMovieMenu);
                    Ux_OpenWindow(&MenuCommonItemCtrl, 0);
                    return NVTEVT_CONSUME;
                }
            }
            gMovData.State = MOV_ST_VIEW;
        break;
    case MOV_ST_MENU:
         g_uiMaskKeyPress = MOVIE_KEY_PRESS_MASK;
         g_uiMaskKeyRelease = MOVIE_KEY_RELEASE_MASK;
         KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);
         KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, g_uiMaskKeyRelease);
            if (SysGetFlag(FL_MOVIE_MOTION_DET)==MOVIE_MOTIONDET_ON)
            {
                g_uiRecordIngMotionDet = TRUE;
            } else {
                g_uiRecordIngMotionDet = FALSE;
            }
         FlowMovie_UpdateIcons(TRUE);
         gMovData.State = MOV_ST_VIEW;
        break;
    }
    Ux_DefaultEvent(pCtrl,NVTEVT_CHILD_CLOSE,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyShutter2(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_OnExeRecord(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnKeyZoomin(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_OnExeZoomIn(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnKeyZoomout(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_OnExeZoomOut(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnKeyUp(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT16 uhFolderId = 0, uhFileId = 0;
        //UINT32 uiBreaklight = FALSE;

	UINT32 uiKeyAct;
	UINT8 i;
    	//debug_msg("UIFlowWndMovie_OnKeyUp..\r\n");
    	uiKeyAct = paramArray[0];
    #if 1
    //if(GPIOMap_GetTVStatus() == FALSE)
    //{
        //GPIOMap_TurnOnLCDBacklight();
       // return;
   // }
    //else
    //{
        /*if(GPIOMap_GetTVStatus() == TRUE)    //eric edit
        {
            GPIOMap_TurnOffLCDBacklight();
            TimerDelayMs(500);
            uiBreaklight = TRUE;
        }*/
    	switch (uiKeyAct)
    	{
        	case NVTEVT_KEY_PRESS:
                  switch (gMovData.State)
		    {
		        case MOV_ST_VIEW:
		        case MOV_ST_VIEW | MOV_ST_ZOOM:
  			 case MOV_ST_REC:
			 case MOV_ST_REC | MOV_ST_ZOOM:
			 	 //Ux_SendEvent(&UIMovieObjCtrl, NVTEVT_EXE_LEDLIGHT, 0);
		             //break;
                  	//}
			 	#if 1
                            //GPIOMap_SetTV(FALSE);
                           /* if(uiBreaklight = TRUE)
                            {
                                for(i=0;i<VIDEO_PATH_LEN;i++)
                                {
                                    I2C_TxByte (0x00,BIT1216M_ITU656_REG[i][0],BIT1216M_ITU656_REG[i][1]);	
                                    //FlowMovie_IconHideDaoche();
                                }
                                TimerDelayMs(500);
                                GPIOMap_TurnOnLCDBacklight();
                                TimerDelayMs(200);
                                GPIOMap_SetTV(FALSE);
                            }
                            break;*/
			if (SysGetFlag(FL_MOVIE_PARKING) == MOVIE_PARKING_ON)
  			{
  				SysSetFlag(FL_MOVIE_PARKING,MOVIE_PARKING_OFF);
  				FlowMovie_IconDrawParking(&UIFlowWndMovie_StatusICN_ParkingCtrl);
				//debug_msg("%s..#################SysSetFlag(FL_MOVIE_PARKING,MOVIE_PARKING_OFF);#############eric_debug\r\n",__func__);
  			}
  			else if (SysGetFlag(FL_MOVIE_PARKING) == MOVIE_PARKING_OFF)
  			{
  				SysSetFlag(FL_MOVIE_PARKING,MOVIE_PARKING_ON);
  				FlowMovie_IconDrawParking(&UIFlowWndMovie_StatusICN_ParkingCtrl);
				//debug_msg("%s..#################SysSetFlag(FL_MOVIE_PARKING,MOVIE_PARKING_ON);#############eric_debug\r\n",__func__);
  			}
		    }
		      // Ux_SendEvent(&UIMovieObjCtrl, NVTEVT_EXE_LEDLIGHT, 0);
		       //SysSetFlag(FL_SILENT,SILENT_ON);
                     //FlowMovie_IconDrawLedLight(&UIFlowWndMovie_Status_LedLightCtrl);
		  break;
		  #endif
      }
    return NVTEVT_CONSUME;
}
#endif
    #if 0
    
    	switch (uiKeyAct)
    	{
        	case NVTEVT_KEY_PRESS:
                  switch (gMovData.State)
		    {
		        case MOV_ST_VIEW:
		        case MOV_ST_VIEW | MOV_ST_ZOOM:
  			 case MOV_ST_REC:
			 case MOV_ST_REC | MOV_ST_ZOOM:
                            //GPIOMap_SetTV(FALSE);
                            if(uiBreaklight = TRUE)
                            {
                                for(i=0;i<VIDEO_PATH_LEN;i++)
                                {
                                    I2C_TxByte (0x00,BIT1216M_ITU656_REG[i][0],BIT1216M_ITU656_REG[i][1]);	
                                    //FlowMovie_IconHideDaoche();
                                }
                                TimerDelayMs(500);
                                GPIOMap_TurnOnLCDBacklight();
                                TimerDelayMs(200);
                                GPIOMap_SetTV(FALSE);
                            }
                            break;
		    }
				break;
    		}
    


    return NVTEVT_CONSUME;
}
#endif
INT32 UIFlowWndMovie_OnKeyPlayBack(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    // Don't stop movie recording
    switch(gMovData.State)
    {
      case MOV_ST_VIEW:
      case MOV_ST_VIEW|MOV_ST_ZOOM:
        // mask key while changing primary mode
        Ux_FlushEvent();
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_NULL);
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, FLGKEY_KEY_MASK_NULL);
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_CONTINUE, FLGKEY_KEY_MASK_NULL);
        // changing primary mode
        Ux_SendEvent(&UISystemObjCtrl,NVTEVT_FORCETO_PLAYBACK_MODE,0);
        break;
    }

    return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnKeyDisplay(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32  uiKeyAct;

    	uiKeyAct = paramArray[0];
	debug_err(("UIFlowWndMovie_OnKeyDisplay gbMoviFileLock : %d ...\r\n",gbMoviFileLock));
    	switch(uiKeyAct)
    	{
    		case NVTEVT_KEY_PRESS:
			switch(gMovData.State)
			{
			      case MOV_ST_VIEW:
			      case MOV_ST_REC:
                           Ux_SendEvent(&UISystemObjCtrl,NVTEVT_EXE_DISPLAY,1,DISPLAY_NORMAL);
                   #if 1   //eric edit
					if (gbMoviFileLock == FALSE)
					{
						gbMoviFileLock = TRUE;
						//debug_err(("---SOS--FilesysSetFileLock --Cur-- : %d - %d---\r\n",SysGetFlag(FL_DCF_FILE_ID),SysGetFlag(FL_DCF_DIR_ID)));					
						UxState_SetData(&UIFlowWndMovie_Status_LOCKCtrl,STATE_CURITEM,UIFlowWndMovie_Status_LOCK_ICON_LOCK);    
						UxCtrl_SetShow(&UIFlowWndMovie_Status_LOCKCtrl, TRUE);	
					}
					else
					{
						gbMoviFileLock = FALSE;
						//debug_err(("---SOS--FilesysSetFileLock --Cur-- : %d - %d---\r\n",SysGetFlag(FL_DCF_FILE_ID),SysGetFlag(FL_DCF_DIR_ID)));					
						UxState_SetData(&UIFlowWndMovie_Status_LOCKCtrl,STATE_CURITEM,UIFlowWndMovie_Status_LOCK_ICON_LOCK);    
						UxCtrl_SetShow(&UIFlowWndMovie_Status_LOCKCtrl, FALSE);	
					}
                    #endif
					break;
			}
			break;
    	}
    	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnBattery(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 //static volatile BOOL bBatteryOn = FALSE;

    UxState_SetData(&UIFlowWndMovie_Status_batteryCtrl,STATE_CURITEM,GetBatteryLevel());
    if (KeyScan_IsUSBPower())
    {
        //bBatteryOn = !bBatteryOn;
        UxCtrl_SetShow(&UIFlowWndMovie_Status_batteryCtrl,TRUE);
    } else {
        UxCtrl_SetShow(&UIFlowWndMovie_Status_batteryCtrl,TRUE);
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyMode(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;

    uiKeyAct = paramArray[0];
    //if(GPIOMap_GetTVStatus() == TRUE)
       // return;
    //else
    {
    	switch(uiKeyAct)
    	{
            case NVTEVT_KEY_PRESS:
// Don't stop movie recording
            switch(gMovData.State)
		{
  		case MOV_ST_VIEW:
  		case MOV_ST_VIEW|MOV_ST_ZOOM:
  			// mask key while changing primary mode
  			Ux_FlushEvent();
  			KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_NULL);
  			KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, FLGKEY_KEY_MASK_NULL);
  			KeyScan_SetKeyMask(KEYSCAN_KEYMODE_CONTINUE, FLGKEY_KEY_MASK_NULL);
  			// changing primary mode
  			Ux_SendEvent(&UISystemObjCtrl,NVTEVT_CHANGE_DSCMODE,1,DSCMODE_CHGTO_NEXT);
  			break;
  		case MOV_ST_REC:
  		case MOV_ST_REC|MOV_ST_ZOOM:
                    if (gbMoviFileLock == FALSE)
                    {
                        gbMoviFileLock = TRUE;
                        //debug_err(("---SOS--FilesysSetFileLock --Cur-- : %d - %d---\r\n",SysGetFlag(FL_DCF_FILE_ID),SysGetFlag(FL_DCF_DIR_ID)));					
                        UxState_SetData(&UIFlowWndMovie_Status_LOCKCtrl,STATE_CURITEM,UIFlowWndMovie_Status_LOCK_ICON_LOCK);    
                        UxCtrl_SetShow(&UIFlowWndMovie_Status_LOCKCtrl, TRUE);	
                    }
                    else
                    {
                        gbMoviFileLock = FALSE;
                        //debug_err(("---SOS--FilesysSetFileLock --Cur-- : %d - %d---\r\n",SysGetFlag(FL_DCF_FILE_ID),SysGetFlag(FL_DCF_DIR_ID)));					
                        UxState_SetData(&UIFlowWndMovie_Status_LOCKCtrl,STATE_CURITEM,UIFlowWndMovie_Status_LOCK_ICON_LOCK);    
                        UxCtrl_SetShow(&UIFlowWndMovie_Status_LOCKCtrl, FALSE);	
                    }
                  #if 0
  			if (SysGetFlag(FL_MOVIE_PARKING) == MOVIE_PARKING_ON)
  			{
  				SysSetFlag(FL_MOVIE_PARKING,MOVIE_PARKING_OFF);
  				FlowMovie_IconDrawParking(&UIFlowWndMovie_StatusICN_ParkingCtrl);
  			}
  			else if (SysGetFlag(FL_MOVIE_PARKING) == MOVIE_PARKING_OFF)
  			{
  				SysSetFlag(FL_MOVIE_PARKING,MOVIE_PARKING_ON);
  				FlowMovie_IconDrawParking(&UIFlowWndMovie_StatusICN_ParkingCtrl);
  			}
                  #endif
  			break;
		}
		break;
    	}
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnMovieFinish(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT16 uhFolderId, uhFileId;
 UINT32 gUIAviRecMaxTime;

    switch (gMovData.State)
    {
      case MOV_ST_REC:
      case MOV_ST_REC|MOV_ST_ZOOM:
           if(UI_Validate_Storage(STORAGE_CHECK_FULL, &(gUIAviRecMaxTime)) != FALSE)
            {
                FilesysGetDCFNextID(&uhFolderId,&uhFileId);
                SysSetFlag(FL_DCF_DIR_ID, uhFolderId);
                SysSetFlag(FL_DCF_FILE_ID, uhFileId);
                //Save_MenuInfo();
            }
            gMovData.State = MOV_ST_VIEW;
            g_uiRecordIngMotionDet = FALSE;
            KeyScan_EnableAutoPoweroff(TRUE);
            KeyScan_EnableUSBDet(TRUE);
            FlowMovie_IconDrawMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
            UxCtrl_SetShow(&UIFlowWndMovie_PanelCtrl,FALSE);
            if (FlowMovie_ChkDrawStoreFullFolderFull() == FALSE)
            {
                FlowMovie_UpdateIcons(TRUE);
                KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, MOVIE_KEY_PRESS_MASK);
            }
        break;
        //The flow here may be only for APC3 stop record than lock file function.
        //To be careful that gMovData have changed in UIFlowMovie_Stop.
        case MOV_ST_VIEW:
            #if 1//(PRJ == APC3)
               if (paramArray[0]==UIFlowWndMovie_Restart_Rec)
               {
                    Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 2, NVTEVT_KEY_PRESS, FLGKEY_PRESSED);
               }
             #endif
            break;
    }
	if(gbMoviFileLock== TRUE)
          {               
		debug_err(("-----UIFlowWndMovie_OnMovieFinish--lock %d, %d---\r\n",SysGetFlag(FL_DCF_FILE_ID),SysGetFlag(FL_DCF_DIR_ID)));        
		FilesysWaitInitFinish(FST_TIME_INFINITE);	 
		FilesysWaitCmdFinish(FST_TIME_INFINITE);   		
		     FilesysSetFileLock(SysGetFlag(FL_DCF_FILE_ID),SysGetFlag(FL_DCF_DIR_ID),  TRUE);
		     FilesysWaitInitFinish(FST_TIME_INFINITE);	 
		     FilesysWaitCmdFinish(FST_TIME_INFINITE);      
			 
			  UIFlowWndMovie_OnExeLockFile(FALSE);
			  UxCtrl_SetShow(&UIFlowWndMovie_Status_LOCKCtrl, FALSE);
  
          }			  
	/*else if(bUSBUnplug == TRUE)
	{
		debug_err(("---22--UIFlowWndMovie_OnMovieFinish--lock %d, %d---\r\n",SysGetFlag(FL_DCF_FILE_ID),SysGetFlag(FL_DCF_DIR_ID)));			          
			FilesysWaitInitFinish(FST_TIME_INFINITE);	 
			FilesysWaitCmdFinish(FST_TIME_INFINITE);           
		     FilesysSetFileLock(SysGetFlag(FL_DCF_FILE_ID)-1,SysGetFlag(FL_DCF_DIR_ID),  TRUE);
		     FilesysWaitInitFinish(FST_TIME_INFINITE);	 
		     FilesysWaitCmdFinish(FST_TIME_INFINITE);   
	}*/

 /* if(gbDoFileProtect == TRUE)//henry 20141209
  {
      debug_err(("finish movie and restart record...\r\n"));
	gbDoFileProtect = FALSE;
      Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);	   	 	
  }	*/

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnMovieOneSec(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT16 uhFolderId, uhFileId;
    static UINT32 uiAVICurrentSec2;
    UINT32 Resulte;
    switch (gMovData.State)
    {
      case MOV_ST_REC:
      case MOV_ST_REC|MOV_ST_ZOOM:
	     uiAVICurrentSec = (paramArray[0]);
           UxCtrl_SetShow(&UIFlowWndMovie_PanelCtrl,!UxCtrl_IsShow(&UIFlowWndMovie_PanelCtrl));
           FlowMovie_IconHideMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
           FlowMovie_IconHideYellowRec(&UIFlowWndMovie_PanelYellowCtrl);//henry 20141215
           FlowMovie_SetRecCurrTime(paramArray[0]);
           FlowMovie_IconDrawRecTime(&UIFlowWndMovie_Static_timeCtrl);
	 /* if((SysGetFlag(FL_MOVIE_LOOP_REC) != MOVIE_CYCLICREC_OFF)&&((paramArray[0]) > (Get_MovieCyclicRecTime()-1)))//henry 20141209 
	  	{
			if((gbMoviFileLock== TRUE)&&(gbDoFileProtect == FALSE))
		          {      
				gbDoFileProtect = TRUE;	  
        			Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);	   	   				
		          }
	        
	  	}*/
/*	  
	  if(gbDoFileProtect == TRUE)
	  {
	      uiAVICurrentSec2++;
		if(uiAVICurrentSec2>3)
		{
		FilesysWaitInitFinish(FST_TIME_INFINITE);	 
		FilesysWaitCmdFinish(FST_TIME_INFINITE);   
		Resulte = FilesysSetFileLock(SysGetFlag(FL_DCF_FILE_ID),SysGetFlag(FL_DCF_DIR_ID),  TRUE);
		debug_err(("----FilesysSetFileLock Resulte : %d---\r\n",Resulte));
		if(Resulte ==FST_STA_BUSY)
		{
    			return NVTEVT_CONSUME;
		}
		else
		{
		FilesysWaitInitFinish(FST_TIME_INFINITE);	 
		FilesysWaitCmdFinish(FST_TIME_INFINITE);     
		uiAVICurrentSec2 =0;
        	gbDoFileProtect = FALSE;          
			
		UIFlowWndMovie_OnExeLockFile(FALSE);	
		UxCtrl_SetShow(&UIFlowWndMovie_Status_LOCKCtrl, FALSE);		
	    FilesysGetDCFNextID(&uhFolderId, &uhFileId);
	    if (uhFolderId > SysGetFlag(FL_DCF_DIR_ID))
	        SysSetFlag(FL_DCF_DIR_ID, uhFolderId);
	    if (uhFileId > SysGetFlag(FL_DCF_FILE_ID))
	        SysSetFlag(FL_DCF_FILE_ID, uhFileId-1);		
		
		debug_err(("-----UIFlowWndMovie_OnMovieOneSec--lock %d, %d---\r\n",SysGetFlag(FL_DCF_FILE_ID)-1,SysGetFlag(FL_DCF_DIR_ID)));
		}		
		}
	  }
*/	  
           break;
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnMovieFull(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
  UINT32 uiAviRecMaxTime;
  UINT16 uhFolderId, uhFileId;

    FlowMovie_StopRec();
    KeyScan_EnableAutoPoweroff(TRUE);
    KeyScan_EnableUSBDet(TRUE);
    if(UI_Validate_Storage(STORAGE_CHECK_FULL, &uiAviRecMaxTime) == TRUE)
    {
        gMovData.State= MOV_ST_VIEW;
        //FilesysGetDCFNextID(&uhFolderId,&uhFileId);
        //SysSetFlag(FL_DCF_DIR_ID, uhFolderId);
        //SysSetFlag(FL_DCF_FILE_ID, uhFileId);
        //Save_MenuInfo();
    }
    else
    {
        gMovData.State= MOV_ST_WARNING_MENU;
        Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_FULL,FLOWWRNMSG_TIMER_2SEC);
    }
    FlowMovie_IconDrawMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);

    return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnMovieWrError(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

    if ((gMovData.State == MOV_ST_REC)||(gMovData.State == (MOV_ST_REC|MOV_ST_ZOOM)))
    {
        FlowMovie_StopRec();
        if (GetCardStatus() == CARD_LOCKED)
        {
            gMovData.State=MOV_ST_WARNING_MENU;
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_LOCKED,FLOWWRNMSG_TIMER_3SEC);
            return NVTEVT_CONSUME;
        }
        else
        {
            gMovData.State=MOV_ST_WARNING_MENU;
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_MEMORYERROR,FLOWWRNMSG_TIMER_3SEC);
            return NVTEVT_CONSUME;
        }
    }
    else
    {
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS,MOVIE_KEY_PRESS_MASK);
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnPreviewStable(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    ide_enable_video(IDE_VIDEOID_1);
    switch (gMovData.State)
    {
    case MOV_ST_VIEW:
        FlowMovie_UpdateIcons(TRUE);
        break;
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnOZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnDZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 AlgMsgInfo *pAlgMsgInfo = Get_AlgMsgInfo();

    /* Update digital zoom ratio OSD string */
    UxStatic_SetData(&UIFlowWndMovie_Zoom_StaticCtrl,STATIC_VALUE,Txt_Pointer(Get_DZoomRatioString(pAlgMsgInfo)));

    if(pAlgMsgInfo->DzoomIndex > UI_DZOOM_IDX_MIN)
        UxCtrl_SetShow(&UIFlowWndMovie_Zoom_StaticCtrl,TRUE);
    else
        UxCtrl_SetShow(&UIFlowWndMovie_Zoom_StaticCtrl,FALSE);

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnStorageChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    FlowMovie_UpdateIcons(TRUE);
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, g_uiMaskKeyRelease);
    return NVTEVT_CONSUME;
}

UINT32 Get_GSensorSensitivity(void)
{
	UINT32 Sensitivity = 0;
	switch(SysGetFlag(FL_GSENSOR))
	{
		case GSENSOR_HIGH:
			Sensitivity = 200;//150;//80
			break;
		case GSENSOR_NORMAL:
			Sensitivity = 300;//90
			break;
		case GSENSOR_LOW:
			Sensitivity = 400;//100
			break;
		case GSENSOR_OFF:
			Sensitivity = 0xff;
			break;
	}
    	return Sensitivity;
}

void KeyScan_DetGSensor(void)
{
	short x = 0,y = 0,z = 0;
	static short prev_x= 0,prev_y= 200,prev_z= 200;
	char upd = 0, rot = 0, prev_rot = 0x0F;
	static UINT32 updCount = 0;
	static BOOL First = TRUE;
       INT32 xyz = Get_GSensorSensitivity();
	   
        if (SysGetFlag(FL_GSENSOR) != GSENSOR_OFF)
        {
        	if (updCount <3)
        	{
        		updCount++;
        	}
		else
		{
                     int ret = mir3da_read_data(&x,&y,&z);
                     //debug_msg("abs_x=%4d abs_y=%4d abs_z=%4d x=%4d y=%4d z=%4d\r\n",abs(x-prev_x ),abs(y-prev_y ),abs(z-prev_z ),x,y,z);
                     if (First == TRUE)
                     {
                     First = FALSE;
                     prev_x = x;
                     prev_y = y;
                     prev_z = z;
                     }                     
            		switch(gMovData.State)
	            	{
	            		case MOV_ST_REC:
                           //debug_err(("^R(GSensor_GMA301_GetStatus(xyz) = %d \r\n",GSensor_GMA301_GetStatus(xyz)));
                           //debug_err(("^RgbMoviFileLock = %d \r\n",gbMoviFileLock));
                                //if ((GSensor_GMA301_GetStatus(xyz) == TRUE)&&(gbMoviFileLock == FALSE))//stephen
                                if (((abs(x-prev_x )> xyz)||(abs(y-prev_y )> xyz)||(abs(z-prev_z )> xyz))&&(gbMoviFileLock == FALSE))
                                {
		                        	debug_err((">>>> gsensor-protect-----\r\n"));
	    					KeyScan_PlaySound(KEYSCAN_SOUND_KEY_OTHERS);
						gbMoviFileLock = TRUE;
						UxState_SetData(&UIFlowWndMovie_Status_LOCKCtrl,STATE_CURITEM,UIFlowWndMovie_Status_LOCK_ICON_LOCK);    
				    		UxCtrl_SetShow(&UIFlowWndMovie_Status_LOCKCtrl, TRUE);
		                    	}
					if (GetGsensorPowerOn() == TRUE)
					{
						gbMoviFileLock = TRUE;
			    			UxState_SetData(&UIFlowWndMovie_Status_LOCKCtrl,STATE_CURITEM,UIFlowWndMovie_Status_LOCK_ICON_LOCK);    
				    		UxCtrl_SetShow(&UIFlowWndMovie_Status_LOCKCtrl, TRUE);
						SetGsensorPowerOn(FALSE);
						//Ux_SendEvent(&UISystemObjCtrl, NVTEVT_EXE_DELAY_POWEROFF, 1, DELAY_POWEROFF_15S);
                                        if (KeyScan_IsUSBPower() !=TRUE)
                                        {
                                          KeyScan_SetDelayShutdownTime(10);
				              KeyScan_EnableDelayShutdown(TRUE);
                                        }
					}
			              break;
    	            		    case MOV_ST_VIEW:
                                   //debug_msg("^R ####GetGsensorPowerOn() =%d \r\n",GetGsensorPowerOn());
                                    if (GetGsensorPowerOn() == TRUE)
                                    {
                                        Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
                                    }
                                   break;
	            		}
		}
            
        }   
}
INT32 UIFlowWndMovie_OnTimer(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 	NVT_USER_EVT userEvent;
       static BOOL  bFirstPowerOn = TRUE;
	   
    	userEvent = paramArray[0];

    	switch(userEvent)
    	{
      		case NVTEVT_05SEC_TIMER:
	    		if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON)
	    		{
	  			if((gMovData.State == MOV_ST_VIEW)||(gMovData.State == (MOV_ST_VIEW|MOV_ST_ZOOM)))
				{
					UxCtrl_SetShow(&UIFlowWndMovie_PanelYellowCtrl,!UxCtrl_IsShow(&UIFlowWndMovie_PanelYellowCtrl));
				}
        			// Motion Detect function
        			if (g_uiRecordIngMotionDet==TRUE)
        			{
          				static UINT32  uiMotionDetGo = 0;
          				static UINT32  uiMotionDetStop = 0;

					if (MotionDetection()==TRUE)
					{
						uiMotionDetGo++;
						if (uiMotionDetGo>=2)
						{
							uiMotionDetStop=0;
							if (!((gMovData.State == MOV_ST_REC)||(gMovData.State == (MOV_ST_REC|MOV_ST_ZOOM))))
							{
								// reset uiMotionDetGo
								uiMotionDetGo = 0;
								// press enter key to record video
								Ux_PostEvent(NVTEVT_KEY_ENTER, 1, NVTEVT_KEY_PRESS);
							}
						}
					} 
					else 
					{
						uiMotionDetStop++;
						if (uiMotionDetStop>=2) // 1 sec
						{
							uiMotionDetGo=0;
						}
                				if (uiMotionDetStop>=24) // 10 Sec
						{
							uiMotionDetStop = 0;
							switch(gMovData.State)
							{
								case MOV_ST_REC:
								case MOV_ST_REC|MOV_ST_ZOOM:
									// stop recording
									if (FlowMovie_GetRecCurrTime() >= 1)
									{
										FlowMovie_StopRec();
									}
									break;
							}
						}
            				}
        			}
	    		}
        		break;
      		case NVTEVT_1SEC_TIMER:
	  		if (bFirstPowerOn == TRUE)
			{
				bFirstPowerOn = FALSE;
				if ((GetGsensorPowerOn() == TRUE)&&(!KeyScan_IsHDMIPlugIn()))
				{
					debug_msg(">>-----GetGsensorPowerOn ----\r\n");
					Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
					return NVTEVT_CONSUME;
				}
				if ((KeyScan_IsUSBPower())&&(!KeyScan_IsHDMIPlugIn()))
				{
					Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
					return NVTEVT_CONSUME;
				}

                        #if (_PROJECT_TUOBU_ == ENABLE)
			        Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
                        #endif
			}
#if (_GSENSOR_FUNC_ == ENABLE)
			KeyScan_DetGSensor();
#endif
        		FlowMovie_OnTimer1SecIndex();
        		//UIFlowWndMovie_Update_Speed();		
        		break;
    	}
    	Ux_DefaultEvent(pCtrl,NVTEVT_TIMER,paramNum,paramArray);
    	return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnRecEventSlow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32  state;

    if (paramNum > 0)
        state = *paramArray;
    debug_err(("UIFlowWndMovie_OnRecEventSlow  %d\n\r",*paramArray));
    switch(state)
    {
    case NVTEVT_KEY_PRESS:
       if(FlowMovie_CheckMemoryForCyclicRec(Get_MovieCyclicRecTime()) == TRUE)
       { 
    		debug_err(("FlowMovie_CheckMemoryForCyclicRec TRUE\n\r"));		 
	  }
    Ux_PostEvent(NVTEVT_KEY_ENTER, 1,NVTEVT_KEY_PRESS);  
    TimerDelayMs(1000);	   
    //Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);	   	 	 
     FlowMovie_StartRec();
		   
      break;
    	}
}
//----------------------UIFlowWndMovie_Static_cameraCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_camera)
EVENT_END

//----------------------UIFlowWndMovie_Status_CyclicRecCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_CyclicRec)
EVENT_END

//----------------------UIFlowWndMovie_Status_MotionDetCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_MotionDet)
EVENT_END

//----------------------UIFlowWndMovie_Status_batteryCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_battery)
EVENT_END

//----------------------UIFlowWndMovie_YMD_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_YMD_Static)
EVENT_END

//----------------------UIFlowWndMovie_HMS_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_HMS_Static)
EVENT_END

//---------------------UIFlowWndMovie_PanelCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_Panel)
CTRL_LIST_END

//----------------------UIFlowWndMovie_PanelCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Panel)
EVENT_END

//----------------------UIFlowWndMovie_Status_StorageCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Storage)
EVENT_END

//----------------------UIFlowWndMovie_Static_timeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_time)
EVENT_END

//----------------------UIFlowWndMovie_Static_maxtimeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_maxtime)
EVENT_END

//----------------------UIFlowWndMovie_Static_resolutionCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_resolution)
EVENT_END

//----------------------UIFlowWndMovie_Zoom_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Zoom_Static)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_EVCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_EV)
EVENT_END

//----------------------UIFlowWndMovie_Status_LedLightCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_LedLight)
EVENT_END

//----------------------UIFlowWndMovie_Status_MovieAudioCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_MovieAudio)
EVENT_END

//----------------------UIFlowWndMovie_Status_LOCKCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_LOCK)
EVENT_END

//----------------------UIFlowWndMovie_Status_GPSCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_GPS)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_ParkingCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_Parking)
EVENT_END

//---------------------UIFlowWndMovie_PanelYellowCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_PanelYellow)
CTRL_LIST_END

//----------------------UIFlowWndMovie_PanelYellowCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_PanelYellow)
EVENT_END

//----------------------UIFlowWndMovie_CarNo_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_CarNo_Static)
EVENT_END

//----------------------UIFlowWndMovie_Status_ZHCarNoCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_ZHCarNo)
EVENT_END

//----------------------UIFlowWndMovie_Status_GSENSORCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_GSENSOR)
EVENT_END

EVENT_BEGIN(UIFlowWndMovie_Status_SHRINK)
EVENT_END

//----------------------UIFlowWndMovie_Static_DAOCHECtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_DAOCHE)
EVENT_END

