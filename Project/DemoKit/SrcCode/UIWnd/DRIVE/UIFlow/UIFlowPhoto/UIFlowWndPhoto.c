//This source code is generated by UI Designer Studio.

#include "UIFramework.h"
#include "UIFrameworkExt.h"
#include "NVTToolCommand.h"
#include "UIFlowWndPhotoRes.c"
#include "UIFlow.h"
#include "PhotoTsk.h"
#include "VoltageDet.h"
#include "GlobalVar.h"
#include "PlaySoundTsk.h"
#include "FWRotate.h"
#include "disp_rotate.h"
#include "PrimaryTsk.h"


#define FD_FRAME_RATE               3//10   //(10frame/30fps) = 333ms = update time

//-----------------------------------------------------------------------------
// UIFlowWndPhoto User Definitions
//-----------------------------------------------------------------------------
// Photo mode key mask
#define PHOTO_KEY_PRESS_MASK        (FLGKEY_KEY_MASK_DEFAULT)
#define PHOTO_KEY_RELEASE_MASK      (FLGKEY_UP | FLGKEY_DOWN | FLGKEY_ENTER | FLGKEY_MODE)
#define PHOTO_KEY_CONTINUE_MASK     FLGKEY_KEY_CONT_MASK_DEFAULT

static UINT32 g_uiMaskKeyPress      = PHOTO_KEY_PRESS_MASK;
static UINT32 g_uiMaskKeyRelease    = PHOTO_KEY_RELEASE_MASK;
static UINT32 g_uiMaskKeyContinue   = PHOTO_KEY_CONTINUE_MASK;

static UINT32 g_uiSelfTimerID       = TIMER_NULL;
static UINT32 g_uiQviewTimerID      = TIMER_NULL;
static volatile BOOL g_bRedLEDOn    = FALSE;
static void UIFlowWndPhoto_SetToQuickView(AlgMsgInfo *pAlgInfo);
static void UIFlowWndPhoto_SetToPreview(void);


//---------------------UIFlowWndPhotoCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndPhoto)
CTRL_LIST_ITEM(UIFlowWndPhoto_StaticICN_DSCMode)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_Selftimer)
CTRL_LIST_ITEM(UIFlowWndPhoto_StaticTXT_FreePic)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_EV)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_ISO)
CTRL_LIST_ITEM(UIFlowWndPhoto_StaticTXT_Size)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_AntiShaking)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_WB)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_FD)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_Quality)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_Storage)
CTRL_LIST_ITEM(UIFlowWndPhoto_StaticTXT_DZoom)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_Battery)
CTRL_LIST_ITEM(UIFlowWndPhoto_StaticTXT_SelftimerCnt)
CTRL_LIST_ITEM(UIFlowWndPhoto_PNL_Histogram)
CTRL_LIST_ITEM(UIFlowWndPhoto_PNL_FDFrame)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_ContinueShot)
CTRL_LIST_END

//----------------------UIFlowWndPhotoCtrl Event---------------------------
INT32 UIFlowWndPhoto_OnOpen(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyUp(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyDown(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyLeft(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyRight(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyShutter1(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyShutter2(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyZoomin(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyZoomout(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyEnter(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyMenu(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyMode(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyPlayback(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnChildClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnStorageInit(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnStorageChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnBattery(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnTimer(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnQVStart(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnJpgOK(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnCapFstOK(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnPreviewStable(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnOZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnDZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnFocusEnd(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnFdEnd(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnSdEnd(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyDisplay(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndPhoto)
EVENT_ITEM(NVTEVT_OPEN_WINDOW,UIFlowWndPhoto_OnOpen)
EVENT_ITEM(NVTEVT_CLOSE_WINDOW,UIFlowWndPhoto_OnClose)
EVENT_ITEM(NVTEVT_KEY_UP,UIFlowWndPhoto_OnKeyUp)
EVENT_ITEM(NVTEVT_KEY_DOWN,UIFlowWndPhoto_OnKeyDown)
EVENT_ITEM(NVTEVT_KEY_LEFT,UIFlowWndPhoto_OnKeyLeft)
EVENT_ITEM(NVTEVT_KEY_RIGHT,UIFlowWndPhoto_OnKeyRight)
EVENT_ITEM(NVTEVT_KEY_SHUTTER1,UIFlowWndPhoto_OnKeyShutter1)
EVENT_ITEM(NVTEVT_KEY_SHUTTER2,UIFlowWndPhoto_OnKeyShutter2)
EVENT_ITEM(NVTEVT_KEY_ZOOMIN,UIFlowWndPhoto_OnKeyZoomin)
EVENT_ITEM(NVTEVT_KEY_ZOOMOUT,UIFlowWndPhoto_OnKeyZoomout)
EVENT_ITEM(NVTEVT_KEY_ENTER,UIFlowWndPhoto_OnKeyEnter)
EVENT_ITEM(NVTEVT_KEY_MENU,UIFlowWndPhoto_OnKeyMenu)
EVENT_ITEM(NVTEVT_KEY_MODE,UIFlowWndPhoto_OnKeyMode)
EVENT_ITEM(NVTEVT_KEY_PLAYBACK,UIFlowWndPhoto_OnKeyPlayback)
EVENT_ITEM(NVTEVT_KEY_DISPLAY,UIFlowWndPhoto_OnKeyDisplay)
EVENT_ITEM(NVTEVT_CHILD_CLOSE,UIFlowWndPhoto_OnChildClose)
EVENT_ITEM(NVTEVT_STORAGE_INIT,UIFlowWndPhoto_OnStorageInit)
EVENT_ITEM(NVTEVT_STORAGE_CHANGE,UIFlowWndPhoto_OnStorageChange)
EVENT_ITEM(NVTEVT_BATTERY,UIFlowWndPhoto_OnBattery)
EVENT_ITEM(NVTEVT_TIMER,UIFlowWndPhoto_OnTimer)
EVENT_ITEM(NVTEVT_CB_QVSTART,UIFlowWndPhoto_OnQVStart)
EVENT_ITEM(NVTEVT_CB_JPGOK,UIFlowWndPhoto_OnJpgOK)
EVENT_ITEM(NVTEVT_CB_CAPFSTOK,UIFlowWndPhoto_OnCapFstOK)
EVENT_ITEM(NVTEVT_CB_PREVIEWSTABLE,UIFlowWndPhoto_OnPreviewStable)
EVENT_ITEM(NVTEVT_CB_OZOOMSTEPCHG,UIFlowWndPhoto_OnOZoomStepChange)
EVENT_ITEM(NVTEVT_CB_DZOOMSTEPCHG,UIFlowWndPhoto_OnDZoomStepChange)
EVENT_ITEM(NVTEVT_CB_FOCUSEND,UIFlowWndPhoto_OnFocusEnd)
EVENT_ITEM(NVTEVT_CB_FDEND,UIFlowWndPhoto_OnFdEnd)
EVENT_ITEM(NVTEVT_CB_SDEND,UIFlowWndPhoto_OnSdEnd)
EVENT_END

void UIFlowWndPhoto_InitCfgSetting(void)
{
    Ux_SendEvent(&UIPhotoObjCtrl,   NVTEVT_EXE_SELFTIMER,       1,  SysGetFlag(FL_SELFTIMER));
    Ux_SendEvent(&UIPhotoObjCtrl,   NVTEVT_EXE_FLASH,           1,  SysGetFlag(FL_FLASH_MODE));
    Ux_SendEvent(&UIPhotoObjCtrl,   NVTEVT_EXE_QUALITY,         1,  SysGetFlag(FL_QUALITY));
    Ux_SendEvent(&UIPhotoObjCtrl,   NVTEVT_EXE_ISO,             1,  SysGetFlag(FL_ISO));
    Ux_SendEvent(&UIPhotoObjCtrl,   NVTEVT_EXE_EV,              1,  SysGetFlag(FL_EV));
    Ux_SendEvent(&UIPhotoObjCtrl,   NVTEVT_EXE_WB,              1,  SysGetFlag(FL_WB));
    Ux_SendEvent(&UIPhotoObjCtrl,   NVTEVT_EXE_COLOR,           1,  SysGetFlag(FL_COLOR_EFFECT));
    Ux_SendEvent(&UIPhotoObjCtrl,   NVTEVT_EXE_METERING,        1,  SysGetFlag(FL_METERING));
    Ux_SendEvent(&UIPhotoObjCtrl,   NVTEVT_EXE_SHARPNESS,       1,  SysGetFlag(FL_SHARPNESS));
    Ux_SendEvent(&UIPhotoObjCtrl,   NVTEVT_EXE_SATURATION,      1,  SysGetFlag(FL_SATURATION));
    Ux_SendEvent(&UIPhotoObjCtrl,   NVTEVT_EXE_FD,              1,  SysGetFlag(FL_FD));
    Ux_SendEvent(&UIPhotoObjCtrl,   NVTEVT_EXE_QUICKREVIEW,     1,  SysGetFlag(FL_QUICK_REVIEW));
    Ux_SendEvent(&UIPhotoObjCtrl,   NVTEVT_EXE_DATEIMPRINT,     1,  SysGetFlag(FL_DATE_STAMP));
//    Ux_SendEvent(&UIPhotoObjCtrl,   NVTEVT_EXE_SCENEMODE,       1,  SysGetFlag(FL_SCENE));

    /* Preview resolution setting must be set after other IQ settings */
    Ux_SendEvent(&UIPhotoObjCtrl,   NVTEVT_EXE_SIZE,            1,  SysGetFlag(FL_PHOTO_SIZE));

    // set FL_CONTINUE_SHOT to off
//    SysSetFlag(FL_CONTINUE_SHOT,CONTINUE_SHOT_OFF);
}

static INT32 UIFlowWndPhoto_OnExeCapture(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 uiEvtKeyAct = 0;

    if(paramNum > 0)
        uiEvtKeyAct = paramArray[0];

    if(GPIOMap_DetStrgCard() == FALSE)
    {
	  gPhotoData.State= MOV_ST_WARNING_MENU;
        Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_NO_CARD,FLOWWRNMSG_TIMER_2SEC);
        return NVTEVT_CONSUME;		
    }
    switch(uiEvtKeyAct)
    {
        case NVTEVT_KEY_PRESS:
        {
            switch (gPhotoData.State)
            {
              case PHOTO_ST_VIEW:
                /* Check if in quick review process */
                if(SysGetFlag(FL_QUICK_REVIEW) != QUICK_REVIEW_0SEC)
                {
                    if(g_uiQviewTimerID != TIMER_NULL)
                    {
                        KeyScan_stopTimer(&g_uiQviewTimerID);
                        //g_bQviewTimerStart = FALSE;

                        /* Set to preview mode */
                        UIFlowWndPhoto_SetToPreview();

                        /* Resume key after quick view completed */
                        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);
                        Ux_FlushEvent();

                        /* Update window info */
                        FlowPhoto_UpdateIcons(TRUE);
                        return NVTEVT_CONSUME;
                    }
                }

                /* Check capture prerequisite */
                if(FlowPhoto_IsStorageErr() == TRUE)
                {
                    debug_err(("UIFlowWndPhoto_OnKeyShutter2: Card or memory full!\r\n"));
                    gPhotoData.State= PHOTO_ST_WARNING_MENU;
                    return NVTEVT_CONSUME;
                }
                if(GetBatteryLevel() == VOLDET_BATTERY_LVL_EMPTY)
                {
                    debug_err(("UIFlowWndPhoto_OnKeyShutter2: Battery is too low!\r\n"));
                    return NVTEVT_CONSUME;
                }

                // check free pic number
                if (SysGetFlag(FL_CONTINUE_SHOT) == CONTINUE_SHOT_ON) {
                    if(FlowPhoto_GetFreePicNum() < 2)
                    {
                        UINT32 uiMsg = 0;

                        uiMsg = (GetCardStatus() == CARD_REMOVED)? UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD : UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_FULL;
                        gPhotoData.State= PHOTO_ST_WARNING_MENU;
                        Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,uiMsg,FLOWWRNMSG_TIMER_2SEC);
                        return NVTEVT_CONSUME;
                    }
                }

                switch (SysGetFlag(FL_SELFTIMER))          // set capture mode by system flag
                {
                case SELFTIMER_2SEC:
                    /* Suspend all keys, except S2 key while selftimer started */
                    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_ENTER);
                    FlowPhoto_IconDrawSelftimerTime(&UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl,2);
                    gPhotoData.SelfTimerCount = 20;              // set time counter
                    gPhotoData.State = PHOTO_ST_SELFTIMER;  // set working state to self-timer state
                    KeyScan_EnableLEDToggle(KEYSCAN_LED_GREEN, TRUE);
                    PlaySound_Play(PLAYSOUND_SOUND_KEY_OTHERS);
                    if (g_uiSelfTimerID == NULL_TIMER)
                    {
                        g_uiSelfTimerID = KeyScan_startTimer(100, NVTEVT_01SEC_TIMER, TIMER_TYPE_CONTINUE);
                    }
                    break;
                case SELFTIMER_5SEC:
                    /* Suspend all keys, except S2 key while selftimer started */
                    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_ENTER);
                    FlowPhoto_IconDrawSelftimerTime(&UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl,5);
                    gPhotoData.SelfTimerCount = 50;         // set time counter
                    gPhotoData.State = PHOTO_ST_SELFTIMER;  // set working state to self-timer state
                    KeyScan_EnableLEDToggle(KEYSCAN_LED_GREEN, TRUE);
                    PlaySound_Play(PLAYSOUND_SOUND_KEY_OTHERS);
                    if (g_uiSelfTimerID == NULL_TIMER)
                    {
                        g_uiSelfTimerID = KeyScan_startTimer(100, NVTEVT_01SEC_TIMER, TIMER_TYPE_CONTINUE);
                    }
                    break;
                case SELFTIMER_10SEC:
                    /* Suspend all keys, except S2 key while selftimer started */
                    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_ENTER);
                    FlowPhoto_IconDrawSelftimerTime(&UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl,10);
                    gPhotoData.SelfTimerCount = 100;        // set time counter
                    gPhotoData.State = PHOTO_ST_SELFTIMER;  // set working state to self-timer state
                    KeyScan_EnableLEDToggle(KEYSCAN_LED_GREEN, TRUE);
                    PlaySound_Play(PLAYSOUND_SOUND_KEY_OTHERS);
                    if (g_uiSelfTimerID == NULL_TIMER)
                    {
                        g_uiSelfTimerID = KeyScan_startTimer(100, NVTEVT_01SEC_TIMER, TIMER_TYPE_CONTINUE);
                    }
                    break;
                default:
                    /* Suspend all keys before sending capture command */
                    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_NULL);
                    Ux_FlushEvent();

                    /* Clear the whole OSD screen */
                    UxCtrl_SetAllChildShow(pCtrl,FALSE);

                    gPhotoData.State = PHOTO_ST_CAPTURE;    // enter capture state
                    FlowPhoto_DoCapture();                  // do capture directly
                    break;
                 }
                break;
                case PHOTO_ST_SELFTIMER:
                     gPhotoData.State = PHOTO_ST_VIEW;
                     gPhotoData.SelfTimerCount = 0;
                     //KeyScan_EnableLEDToggle(KEYSCAN_LED_GREEN, FALSE);
                     FlowPhoto_IconHideSelftimer(&UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl);
                     // resume press mask to default
                     KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);
                    break;
            }
            break;
        }

        case NVTEVT_KEY_RELEASE:
        {
            //Rsvd
            break;
        }

        default:
            debug_err(("UIFlowWndPhoto_OnKeyShutter2: Unknown evt 0x%x\r\n", uiEvtKeyAct));
            break;
    }
    return NVTEVT_CONSUME;
}

static INT32 UIFlowWndPhoto_OnExeZoomIn(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 uiEvtKeyAct = 0;

    if(paramNum > 0)
        uiEvtKeyAct = paramArray[0];

    switch(uiEvtKeyAct)
    {
        case NVTEVT_KEY_PRESS:
        case FLGKEY_HOLD:
            if ((Photo_GetDZoomIdx()-10) > UI_DZOOM_IDX_MAX)
              {
                Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_ZOOMSTOP,0);
                gPhotoData.State &= ~PHOTO_ST_ZOOM;
                return NVTEVT_CONSUME;
              }
            switch(gPhotoData.State)
            {
              case PHOTO_ST_VIEW:
              case PHOTO_ST_VIEW|PHOTO_ST_ZOOM:
                   /*
                    * Suspend all keys while keep ZoomIn pressed.
                    * Gotta resume them after ZoomIn key released.
                    */
                   KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_NULL);
                   FlowPhoto_ForceLockFdSd();
                   gPhotoData.State |= PHOTO_ST_ZOOM;
                   Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_ZOOMIN,0);
                break;
            }
            break;

        case NVTEVT_KEY_RELEASE:
             Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_ZOOMSTOP,0);
             gPhotoData.State &= ~PHOTO_ST_ZOOM;
             FlowPhoto_SetFdSdProc();
             /* Resume keys after ZoomIn released */
             KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);
            break;

        default:
            debug_err(("UIFlowWndPhoto_OnKeyZoomin: Unknown evt 0x%x\r\n", uiEvtKeyAct));
            break;
    }

    return NVTEVT_CONSUME;
}

static INT32 UIFlowWndPhoto_OnExeZoomOut(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32 uiEvtKeyAct = 0;

    if(paramNum > 0)
        uiEvtKeyAct = paramArray[0];

    switch(uiEvtKeyAct)
    {
        case NVTEVT_KEY_PRESS:
        case FLGKEY_HOLD:

            switch(gPhotoData.State)
            {
              case PHOTO_ST_VIEW:
              case PHOTO_ST_VIEW|PHOTO_ST_ZOOM:
                   /*
                    * Suspend all keys while keep ZoomIn pressed.
                    * Gotta resume them after ZoomIn key released.
                    */
                   KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_NULL);
                   FlowPhoto_ForceLockFdSd();
                   gPhotoData.State |= PHOTO_ST_ZOOM;
                   Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_ZOOMOUT,0);
                break;
            }
            break;

        case NVTEVT_KEY_RELEASE:
             Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_ZOOMSTOP,0);
             gPhotoData.State &= ~PHOTO_ST_ZOOM;
             FlowPhoto_SetFdSdProc();
             /* Resume keys after ZoomIn released */
             KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);
            break;

        default:
            debug_err(("UIFlowWndPhoto_OnKeyZoomOut: Unknown evt 0x%x\r\n", uiEvtKeyAct));
            break;
    }

    return NVTEVT_CONSUME;
}


INT32 UIFlowWndPhoto_OnOpen(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

    /* Init window key mask variables & set key press/release/continue mask */
    gPhotoData.State = PHOTO_ST_VIEW;
    g_uiMaskKeyPress = PHOTO_KEY_PRESS_MASK;
    g_uiMaskKeyRelease = PHOTO_KEY_RELEASE_MASK;
    g_uiMaskKeyContinue = PHOTO_KEY_CONTINUE_MASK;
    Ux_FlushEvent();
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, g_uiMaskKeyRelease);
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_CONTINUE, g_uiMaskKeyContinue);
    gPhotoData.SysTimeCount = 0;
    /* Update window info */
    FlowPhoto_UpdateIcons(TRUE);
    /* set FD/SD feature */
    FlowPhoto_SetFdSdProc();

    Ux_DefaultEvent(pCtrl,NVTEVT_OPEN_WINDOW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

    // stop SelTimerID/QViewTimerID
    if (g_uiSelfTimerID != TIMER_NULL)
    {
        KeyScan_stopTimer(&g_uiSelfTimerID);
    }

    if (g_uiQviewTimerID != TIMER_NULL)
    {
        KeyScan_stopTimer(&g_uiQviewTimerID);
    }

    /* Once close photo window, reset selftimer to off state */
//    SysSetFlag(FL_SELFTIMER, SELFTIMER_OFF);

    g_bRedLEDOn = FALSE;
    KeyScan_TurnOffLED(KEYSCAN_LED_RED);

    gPhotoData.QuickViewCount = 0;
    gPhotoData.SelfTimerCount = 0;

    /* Reset key press/release/continue mask to default */
    Ux_FlushEvent();
//    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_DEFAULT);
//    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, FLGKEY_KEY_REL_MASK_DEFAULT);
//    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_CONTINUE, FLGKEY_KEY_CONT_MASK_DEFAULT);

    Ux_DefaultEvent(pCtrl,NVTEVT_CLOSE_WINDOW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyUp(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndPhoto_OnExeZoomIn(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndPhoto_OnKeyDown(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndPhoto_OnExeZoomOut(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndPhoto_OnKeyLeft(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32  uiKeyAct;
 UINT32 uiEV;

   uiKeyAct = paramArray[0];

    switch(uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
         switch(gPhotoData.State)
         {
            case PHOTO_ST_VIEW:
            case PHOTO_ST_VIEW|PHOTO_ST_ZOOM:
                uiEV = SysGetFlag(FL_EV);
                if (uiEV==EV_N20)
                {
                    SysSetFlag(FL_EV,EV_P20);
                } else {
                    SysSetFlag(FL_EV,++uiEV);
                }

                Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_EXE_EV,1, SysGetFlag(FL_EV));
                FlowPhoto_IconDrawEV(&UIFlowWndPhoto_StatusICN_EVCtrl);
            break;
         }
        break;
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyRight(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32  uiKeyAct;

   uiKeyAct = paramArray[0];

    switch (uiKeyAct)
    {
     case NVTEVT_KEY_PRESS:
        if (g_bRedLEDOn ==FALSE) {
            g_bRedLEDOn =TRUE;
            KeyScan_TurnOnLED(KEYSCAN_LED_RED);
        } else {
            g_bRedLEDOn = FALSE;
            KeyScan_TurnOffLED(KEYSCAN_LED_RED);
        }
        break;
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyShutter1(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyShutter2(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndPhoto_OnExeCapture(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndPhoto_OnKeyZoomin(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndPhoto_OnExeZoomIn(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndPhoto_OnKeyZoomout(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndPhoto_OnExeZoomOut(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndPhoto_OnKeyEnter(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    //return NVTEVT_CONSUME;
    return UIFlowWndPhoto_OnExeCapture(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndPhoto_OnKeyMenu(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32  uiKeyAct;

    uiKeyAct = paramArray[0];

    switch(uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
        switch(gPhotoData.State)
        {
        case PHOTO_ST_VIEW:
            /* Force to lock FD/SD functions before opening Menu */
            FlowPhoto_ForceLockFdSd();
            KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, FLGKEY_KEY_MASK_NULL);

            // Set Tab menu to Photo menu
            TM_SetMenu(&gPhotoMenu);
            // Open common mix (Item + Option) menu
            Ux_OpenWindow((VControl *)(&MenuCommonItemCtrl), 0);
            gPhotoData.State = PHOTO_ST_MENU;
            break;
        }
        break;
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyMode(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32 uiKeyAct;

    if (paramNum==1)
    {
        uiKeyAct = paramArray[0];
    }

    switch(uiKeyAct)
    {
     case NVTEVT_KEY_PRESS:
        Ux_FlushEvent();
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_NULL);
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, FLGKEY_KEY_MASK_NULL);
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_CONTINUE, FLGKEY_KEY_MASK_NULL);
        GPIOMap_TurnOffLCDBacklight();//jack lan 		
        Ux_SendEvent(&UISystemObjCtrl,NVTEVT_CHANGE_DSCMODE,1,DSCMODE_CHGTO_NEXT);
        break;
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyPlayback(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    switch (gPhotoData.State)
    {
      case PHOTO_ST_VIEW:
      case (PHOTO_ST_VIEW|PHOTO_ST_ZOOM):
        Ux_FlushEvent();
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_NULL);
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, FLGKEY_KEY_MASK_NULL);
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_CONTINUE, FLGKEY_KEY_MASK_NULL);
        Ux_SendEvent(&UISystemObjCtrl,NVTEVT_FORCETO_PLAYBACK_MODE,0);
        break;
    }

    return NVTEVT_CONSUME;
}

INT32 UIFlowWndPhoto_OnKeyDisplay(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32  uiKeyAct;
	UINT32  uiPhotoEV;
	
    	uiKeyAct = paramArray[0];

    	switch(uiKeyAct)
    	{
            case NVTEVT_KEY_PRESS:
                Ux_SendEvent(&UISystemObjCtrl,NVTEVT_EXE_DISPLAY,1,DISPLAY_NORMAL);
              #if 0
			//debug_err(("henry------------------photo display\r\n"));
			uiPhotoEV = SysGetFlag(FL_EV)+1;
			if (uiPhotoEV >= EV_ID_MAX)	
			{
			       uiPhotoEV = EV_P20;
				
			}
			SysSetFlag(FL_EV, uiPhotoEV);
			Ux_SendEvent(&UIPhotoObjCtrl, NVTEVT_EXE_EV, 1, uiPhotoEV);
			FlowPhoto_IconDrawEV(&UIFlowWndPhoto_StatusICN_EVCtrl);
            #endif
			break;
    	}
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndPhoto_OnChildClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

    /* Set key mask to self-original state */
    Ux_FlushEvent();
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, g_uiMaskKeyRelease);
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_CONTINUE, g_uiMaskKeyContinue);

    switch (gPhotoData.State)
    {
      case PHOTO_ST_WARNING_MENU:
            if(paramNum > 0)
            {
                if(paramArray[0] == NVTRET_ENTER_MENU)
                {
                    /* Force to lock FD/SD functions before opening Menu */
                    FlowPhoto_ForceLockFdSd();
                    /* Create Menu window */
                    gPhotoData.State = PHOTO_ST_MENU;
                    TM_SetMenu(&gPhotoMenu);
                    Ux_OpenWindow(&MenuCommonItemCtrl, 0);
                    return NVTEVT_CONSUME;
                }
            }
            gPhotoData.State = PHOTO_ST_VIEW;
        break;

      case PHOTO_ST_MENU:
            gPhotoData.State = PHOTO_ST_VIEW;
            /* Set FD/SD functions againg after exiting Menu */
            FlowPhoto_SetFdSdProc();
            /* Update window info */
            FlowPhoto_UpdateIcons(TRUE);
        break;
    }

    Ux_DefaultEvent(pCtrl,NVTEVT_CHILD_CLOSE,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnStorageInit(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnStorageChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnBattery(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 //static volatile BOOL bBatteryOn = FALSE;

    UxState_SetData(&UIFlowWndPhoto_StatusICN_BatteryCtrl,STATE_CURITEM,GetBatteryLevel());
    if (KeyScan_IsUSBPower())
    {
        //bBatteryOn = !bBatteryOn;
        UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_BatteryCtrl,TRUE);
    } else {
        UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_BatteryCtrl,TRUE);
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnTimer(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 NVTEVT event;


    event = paramArray[0];
    switch(event)
    {
      case NVTEVT_01SEC_TIMER:
        if (gPhotoData.QuickViewCount !=0)
        {
            gPhotoData.QuickViewCount--;
            if (gPhotoData.QuickViewCount == 0)
            {
                if (g_uiQviewTimerID != NULL_TIMER)
                {
                    KeyScan_stopTimer(&g_uiQviewTimerID);
                }

                /* Update window info */
                FlowPhoto_UpdateIcons(TRUE);

                /* set FD/SD feature */
                FlowPhoto_SetFdSdProc();

                /* Set to preview mode */
                UIFlowWndPhoto_SetToPreview();

                /* Resume key after normal capture completed */
                KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);
                Ux_FlushEvent();
            }
        }

        if (gPhotoData.SelfTimerCount != 0)
        {
            gPhotoData.SelfTimerCount--;
            if (gPhotoData.SelfTimerCount == 0)
            {
                if (g_uiSelfTimerID != NULL_TIMER)
                {
                    KeyScan_stopTimer(&g_uiSelfTimerID);
                }

                // stopping LED toggle
                KeyScan_EnableLEDToggle(KEYSCAN_LED_GREEN, FALSE);
            }
            FlowPhoto_OnTimer01SecIndex();
        }
        break;
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnQVStart(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 AlgMsgInfo *pAlgMsgInfo = Get_AlgMsgInfo();
 static UINT8 ContinueShotRoundCnt=0;

    debug_err(("UIFlowWndPhoto: OnQVStart\r\n"));
    /* Set to quick review mode */
    UIFlowWndPhoto_SetToQuickView(pAlgMsgInfo);
    if(SysGetFlag(FL_CONTINUE_SHOT) == CONTINUE_SHOT_OFF)
    {
        switch(SysGetFlag(FL_QUICK_REVIEW))
        {
           case QUICK_REVIEW_2SEC:
             gPhotoData.QuickViewCount = 15;
            break;
           case QUICK_REVIEW_5SEC:
             gPhotoData.QuickViewCount = 45;
            break;
           case QUICK_REVIEW_0SEC:
             gPhotoData.QuickViewCount = 1;
            break;
        }
    }
    else
    {
        if (GPIOMap_DetStrgCard() == FALSE)
        {
            gPhotoData.QuickViewCount = 12;
        }
        else
        {
            ContinueShotRoundCnt++;
            if (ContinueShotRoundCnt == 5)
            {
                ContinueShotRoundCnt = 0;
                gPhotoData.QuickViewCount = 12;
            }
            else
            {
                gPhotoData.QuickViewCount = 0;
            }
        }
    }

    if (g_uiQviewTimerID == NULL_TIMER)
    {
        /* Resume only S2 key while quick view timer started */
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_SHUTTER2);
        g_uiQviewTimerID = KeyScan_startTimer(100, NVTEVT_01SEC_TIMER, TIMER_TYPE_CONTINUE);
    }


#if 0

    /* Check quick review state */
    if(SysGetFlag(FL_QUICK_REVIEW) != QUICK_REVIEW_0SEC)   //Quick review on case
    {
        switch(SysGetFlag(FL_QUICK_REVIEW))
        {
           case QUICK_REVIEW_2SEC:
             gPhotoData.QuickViewCount = 15;
            break;
           case QUICK_REVIEW_5SEC:
             gPhotoData.QuickViewCount = 45;
            break;
        }
        /* Set to quick review mode */
        UIFlowWndPhoto_SetToQuickView(pAlgMsgInfo);
        g_uiQviewTimerID = KeyScan_startTimer(100, NVTEVT_01SEC_TIMER, TIMER_TYPE_CONTINUE);

        /* Resume only S2 key while quick view timer started */
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_SHUTTER2);

        /* Than set only essential areas shown when DSC is processing QuickView */
        //Rsvd
    }
    else   //Quick review off case
    {
        // set quick time 1200ms in normal case
        gPhotoData.QuickViewCount = 1;//12;
        /* Set to quick review mode */
        UIFlowWndPhoto_SetToQuickView(pAlgMsgInfo);

        if (gPhotoData.QuickViewCount!=0)
            g_uiQviewTimerID = KeyScan_startTimer(100, NVTEVT_01SEC_TIMER, TIMER_TYPE_CONTINUE);

        /* Resume only S2 key while quick view timer started */
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_SHUTTER2);
    }
#endif
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnJpgOK(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnCapFstOK(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

    /* After capture disable selftime func everytime */
//    SysSetFlag(FL_SELFTIMER, SELFTIMER_OFF);

    /* Resume key after normal capture completed */
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);
    Ux_FlushEvent();

    /* Update window info */
    FlowPhoto_UpdateIcons(TRUE);

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnPreviewStable(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT16 uhFilesysDirNum, uhFilesysFileNum;

#if 0
    /* After capture disable selftime func everytime */
    SysSetFlag(FL_SELFTIMER, SELFTIMER_OFF);

    /* Resume key after normal capture completed */
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);
    Ux_FlushEvent();

    /* Update window info */
    FlowPhoto_UpdateIcons(TRUE);
#endif
    FilesysGetDCFNextID(&uhFilesysDirNum, &uhFilesysFileNum);
    SysSetFlag(FL_DCF_DIR_ID, uhFilesysDirNum);
    SysSetFlag(FL_DCF_FILE_ID, uhFilesysFileNum);

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnOZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnDZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 AlgMsgInfo *pAlgMsgInfo = Get_AlgMsgInfo();

    /* Update digital zoom ratio OSD string */
    UxStatic_SetData(&UIFlowWndPhoto_StaticTXT_DZoomCtrl,STATIC_VALUE,Txt_Pointer(Get_DZoomRatioString(pAlgMsgInfo)));
    //UxStatic_SetData(&UIFlowWndPhoto_StaticTXT_DZoomCtrl,STATIC_VALUE,Txt_Pointer(Get_DigitalZoomString()));
    if(pAlgMsgInfo->DzoomIndex > UI_DZOOM_IDX_MIN)
    //if(Photo_GetDZoomIdx() > UI_DZOOM_IDX_MIN)
        UxCtrl_SetShow(&UIFlowWndPhoto_StaticTXT_DZoomCtrl,TRUE);
    else
        UxCtrl_SetShow(&UIFlowWndPhoto_StaticTXT_DZoomCtrl,FALSE);

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnFocusEnd(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnFdEnd(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    if (SysGetFlag(FL_FD) != FD_OFF)
    {
        if ((gPhotoData.State!=PHOTO_ST_CAPTURE)&&(gPhotoData.QuickViewCount==0))
        {
            /* Enable FD frame show */
            UxCtrl_SetShow(&UIFlowWndPhoto_PNL_FDFrameCtrl,TRUE);

            /* Redraw all window OSD */
            UxCtrl_SetDirty(pCtrl, TRUE);
        }
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnSdEnd(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 #define    SDCount 6
 static UINT32 uiSDCount=0;

    if (SysGetFlag(FL_SELFTIMER)==SELFTIMER_SINGLE)
    {
        if (uiSDCount++>=SDCount)
        {
            uiSDCount=0;
            Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
        }
    }
    return NVTEVT_CONSUME;
}
//----------------------UIFlowWndPhoto_StaticICN_DSCModeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StaticICN_DSCMode)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_SelftimerCtrl Event---------------------------
INT32 UIFlowWndPhoto_StatusICN_Selftimer_OnKeyLeft(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_Selftimer)
EVENT_ITEM(NVTEVT_KEY_LEFT,UIFlowWndPhoto_StatusICN_Selftimer_OnKeyLeft)
EVENT_END

INT32 UIFlowWndPhoto_StatusICN_Selftimer_OnKeyLeft(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    /* Increase item index */
    Ux_SendEvent(pCtrl,NVTEVT_NEXT_ITEM,0);
    /* Send exe to obj for handling (including set ui index) */
    Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_EXE_SELFTIMER,1,UxState_GetData(pCtrl,STATE_CURITEM));
    return NVTEVT_CONSUME;
}
//----------------------UIFlowWndPhoto_StaticTXT_FreePicCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StaticTXT_FreePic)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_EVCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_EV)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_ISOCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_ISO)
EVENT_END

//----------------------UIFlowWndPhoto_StaticTXT_SizeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StaticTXT_Size)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_AntiShakingCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_AntiShaking)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_WBCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_WB)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_FDCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_FD)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_QualityCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_Quality)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_StorageCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_Storage)
EVENT_END

//----------------------UIFlowWndPhoto_StaticTXT_DZoomCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StaticTXT_DZoom)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_BatteryCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_Battery)
EVENT_END

//----------------------UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StaticTXT_SelftimerCnt)
EVENT_END

//---------------------UIFlowWndPhoto_PNL_HistogramCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndPhoto_PNL_Histogram)
CTRL_LIST_END

//----------------------UIFlowWndPhoto_PNL_HistogramCtrl Event---------------------------
INT32 UIFlowWndPhoto_PNL_Histogram_OnTimer(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_PNL_Histogram_OnRedraw(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndPhoto_PNL_Histogram)
EVENT_ITEM(NVTEVT_TIMER,UIFlowWndPhoto_PNL_Histogram_OnTimer)
EVENT_ITEM(NVTEVT_REDRAW,UIFlowWndPhoto_PNL_Histogram_OnRedraw)
EVENT_END

INT32 UIFlowWndPhoto_PNL_Histogram_OnTimer(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_PNL_Histogram_OnRedraw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
//---------------------UIFlowWndPhoto_PNL_FDFrameCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndPhoto_PNL_FDFrame)
CTRL_LIST_END

//----------------------UIFlowWndPhoto_PNL_FDFrameCtrl Event---------------------------
INT32 UIFlowWndPhoto_PNL_FDFrame_OnRedraw(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndPhoto_PNL_FDFrame)
EVENT_ITEM(NVTEVT_REDRAW,UIFlowWndPhoto_PNL_FDFrame_OnRedraw)
EVENT_END

INT32 UIFlowWndPhoto_PNL_FDFrame_OnRedraw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    AlgMsgInfo *pInfo = Get_AlgMsgInfo();
    UIScreen ScreenObj = *paramArray;
    RECT *pFace;
    UINT32 i;

    GxGfx_SetShapeColor(_OSD_INDEX_GREEN, _OSD_INDEX_GREEN, 0);

    for(i=0; i<pInfo->FaceDetectNum; i++)
    {
        pFace = &(pInfo->FaceDetectRect[i]);
        debug_ind(("^RFDFrame[%02d] (%03d/%03d/%03d/%03d)\r\n", i, pFace->uiLeft, pFace->uiTop, pFace->uiWidth, pFace->uiHeight));

        /* Rectangle frame style */
        GxGfx_SetShapeStroke(LINESTYLE_LINE|LINEBRUSH_CIRCLE|LINEWEIGHT(1), SHAPEFILLSTYLE_DEFAULT);
        if(0)//(FWRotate_GetStatus()==TRUE)
        {
        /*
          x'=-(y-h/2)+w/2
          y'=(x-w/2)+h/2
        */
        LVALUE X0,Y0;

          X0= -(pFace->uiTop+pFace->uiHeight>>1)+pFace->uiWidth>>1;
          Y0= (pFace->uiLeft-pFace->uiWidth>>1)+pFace->uiHeight>>1;
        GxGfx_FrameRect(((DC**)ScreenObj)[GxGfx_OSD], X0,
                                                      Y0,
                                                      X0+pFace->uiWidth,
                                                      Y0+pFace->uiWidth);
                                                      //Y0+pFace->uiHeight);
#if 0
        GxGfx_FrameRect(((DC**)ScreenObj)[GxGfx_OSD], pFace->uiTop,
                                                      pFace->uiLeft,
                                                      pFace->uiTop+pFace->uiHeight,
                                                      pFace->uiLeft+pFace->uiWidth);
#endif
        } else {
        GxGfx_FrameRect(((DC**)ScreenObj)[GxGfx_OSD], pFace->uiLeft+36,
                                                      pFace->uiTop-16,
                                                      (pFace->uiLeft+36)+pFace->uiWidth+16,
                                                      (pFace->uiTop-16)+pFace->uiWidth+16);
        }
        GxGfx_SetShapeStroke(SHAPELINESTYLE_DEFAULT, SHAPEFILLSTYLE_DEFAULT);
    }

    return NVTEVT_CONSUME;
}
//----------------------UIFlowWndPhoto_StatusICN_ContinueShotCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_ContinueShot)
EVENT_END

static void UIFlowWndPhoto_SetToQuickView(AlgMsgInfo *pAlgInfo)
{
    VIDEO_BUF_ADDR      FB_Addr;
    VIDEO_BUF_ATTR      FB_attr;
    VOSD_WINDOW_ATTR    FB_win;
    INT32 i;

    FB_Addr.uiBufSel        = IDE_VIDEO_ADDR_SEL_BUFFER0;

    FB_attr.Buf_W           = pAlgInfo->Thumbnail_Hsize;
    FB_attr.Buf_H           = pAlgInfo->Thumbnail_Vsize;

    FB_attr.Buf_Lineoffset  = pAlgInfo->Thumbnail_Hsize >> 2;
    FB_attr.Buf_L2R         = IDE_BUFFER_READ_L2R;
    FB_attr.Buf_T2B         = IDE_BUFFER_READ_T2B;
    FB_attr.Buf_BJmode      = IDE_VIDEO_BJMODE_BUFFER_REPEAT;

    FB_attr.Buf_Opt         = IDE_VIDEO_BUFFER_OPT_0;
    FB_attr.Buf_Num         = IDE_VIDEO_BUFFER_NUM_1;

    FB_win.Source_W         = pAlgInfo->Thumbnail_Hsize;
    FB_win.Source_H         = pAlgInfo->Thumbnail_Vsize;

    if ((SysGetFlag(FL_PHOTO_SIZE)==PHOTO_SIZE_7MHD) || (SysGetFlag(FL_PHOTO_SIZE)==PHOTO_SIZE_2MHD))
    {
    FB_win.Des_W            = g_LCDSize.uiWinWidth;
        FB_win.Des_H            = g_LCDSize.uiWinWidth*9/16;
        FB_win.Win_X            = 0;
        FB_win.Win_Y            = (g_LCDSize.uiWinHeight- FB_win.Des_H)/2;
    }
    else
    {
        FB_win.Des_W            = g_LCDSize.uiWinWidth;
        FB_win.Des_H            = g_LCDSize.uiWinHeight;
    FB_win.Win_X            = 0;
    FB_win.Win_Y            = 0;
    }
    FB_win.High_Addr        = 0;

    switch(pAlgInfo->Thumbnail_Format)
    {
    case JPEG_FORMAT_420:
        FB_win.Win_Format   = COLOR_YCBCR420;
        break;
    case JPEG_FORMAT_444:
        FB_win.Win_Format   = COLOR_YCBCR444;
        break;
    case JPEG_FORMAT_422:
    default:
        FB_win.Win_Format   = COLOR_YCBCR422;
        break;
    }

    if (FWRotate_GetStatus()==FALSE)
    {
        ide_set_video_buf_attr(IDE_VIDEOID_1, &FB_attr);
        ide_set_video_win_attr(IDE_VIDEOID_1, &FB_win);
    }
    // Display quick view
    for(i=0; i<pAlgInfo->Jpeg_Num; i++)
    {
        switch(i)
        {
        case 0:
                FB_Addr.B0_Y            = pAlgInfo->Thumbnail0_Y_Addr;
                FB_Addr.B0_CB           = pAlgInfo->Thumbnail0_Cb_Addr;
                FB_Addr.B0_CR           = pAlgInfo->Thumbnail0_Cr_Addr;
            break;

        case 1:
                FB_Addr.B0_Y            = pAlgInfo->Thumbnail1_Y_Addr;
                FB_Addr.B0_CB           = pAlgInfo->Thumbnail1_Cb_Addr;
                FB_Addr.B0_CR           = pAlgInfo->Thumbnail1_Cr_Addr;
            break;

        case 2:
                FB_Addr.B0_Y            = pAlgInfo->Thumbnail2_Y_Addr;
                FB_Addr.B0_CB           = pAlgInfo->Thumbnail2_Cb_Addr;
                FB_Addr.B0_CR           = pAlgInfo->Thumbnail2_Cr_Addr;
            break;

        default:
            debug_err(("Invalid image number!!\r\n"));
            return;
        }

        //ide_set_video_buf_addr(IDE_VIDEOID_1, &FB_Addr);
        if (FWRotate_GetStatus()==TRUE)
        {
         DISPROT_TRIG DispRotTrig;
         DISPROT_PARAM  RotParam;
         DISPLAYER  CurDisplayer;
         DISPLAYER_PARAM EmuDispLyr;
         PDISP_OBJ       pDispObj;

            FWRotate_SetVideoAttrib(IDE_VIDEOID_1,&FB_Addr,&FB_attr,&FB_win);

            disprot_lock();
            RotParam.SEL.SET_INPUT_DIM.DispID      = DISP_1;
            RotParam.SEL.SET_INPUT_DIM.DispLayer   = DISPLAYER_VDO1;
            RotParam.SEL.SET_INPUT_DIM.uiSrcWidth  = FB_attr.Buf_W;//pVdosd->uiWidth;
            RotParam.SEL.SET_INPUT_DIM.uiSrcHeight = FB_attr.Buf_H;
            RotParam.SEL.SET_INPUT_DIM.uiSrcLoffY   = (FB_attr.Buf_W+3)&0xFFFFFFFC;

            switch (pAlgInfo->Thumbnail_Format)
            {
              case JPEG_FORMAT_422:
              default:
                RotParam.SEL.SET_INPUT_DIM.uiSrcLoffUV   = RotParam.SEL.SET_INPUT_DIM.uiSrcLoffY;
                break;
              case JPEG_FORMAT_420:
                RotParam.SEL.SET_INPUT_DIM.uiSrcLoffUV   = RotParam.SEL.SET_INPUT_DIM.uiSrcLoffY>>1;
                break;
            }
            disprot_setParameter(DISPROT_OP_SET_INPUT_DIM, &RotParam);

            DispRotTrig.DispID      = DISP_1;
            DispRotTrig.DispLayer   = DISPLAYER_VDO1;
            DispRotTrig.SrcBufAddr[DISPROT_BUF_Y] = FB_Addr.B0_Y;
            DispRotTrig.SrcBufAddr[DISPROT_BUF_U] = FB_Addr.B0_CB;
            DispRotTrig.SrcBufAddr[DISPROT_BUF_V] = FB_Addr.B0_CR;

            DispRotTrig.bLoadDisp = TRUE;
            disprot_trigger(&DispRotTrig);
            disprot_unlock();
        }else {
            ide_set_video_buf_addr(IDE_VIDEOID_1, &FB_Addr);
        }
        ide_wait_frame_end();
        ide_enable_video(IDE_VIDEOID_1);
        ide_set_load();
    }

}

static void UIFlowWndPhoto_SetToPreview(void)
{
    IPL_OBJ IplObj;

    gPhotoData.State = PHOTO_ST_VIEW;
    ide_disable_video(IDE_VIDEOID_1);

    IplObj.uiImeOutWidth1   = GetDisplayH();
    IplObj.uiImeOutHeight1  = GetDisplayV();
    IplObj.uiImeOutYoft1    = GetDisplayH();
    IplObj.uiDzoomStep      = Get_DzoomIndex();
    IplObj.uiCmd            = IPL_CMD_CHG_MODE;
    IplObj.Mode             = IPL_MODE_PREVIEW;
    IplObj.uiImgFmt         = IMEOUT2_FMT422_2;
    if (IPL_SetCmd(&IplObj) == E_BOVR)
    {
        IplObj.uiImgFmt = IMEOUT2_FMT420_2;
        IPL_SetCmd(&IplObj);
    }

    ide_enable_video(IDE_VIDEOID_1);
    KeyScan_EnableAutoPoweroff(TRUE); //disable auto poweroff,while recording
    KeyScan_EnableUSBDet(TRUE);
}

